package position

// postion/position.gno implements liquidity position manangement for the Gnoswap protocol.
// It handles the creation, modification, and fee collection od liquidity positions.

import (
	"encoding/base64"
	"std"

	"gno.land/p/demo/ufmt"
	"gno.land/r/demo/wugnot"
	"gno.land/r/gnoswap/v1/gnft"

	u256 "gno.land/p/gnoswap/uint256"

	"gno.land/r/gnoswap/v1/common"
	"gno.land/r/gnoswap/v1/consts"

	en "gno.land/r/gnoswap/v1/emission"
	pl "gno.land/r/gnoswap/v1/pool"
)

const (
	MAX_RATIO uint64 = 100
	ZERO_LIQUIDITY_FOR_FEE_COLLECTION = "0"
)

var (
	// TODO (@notJoon): use avl tree, after #440 is merged
	positions map[uint64]Position = make(map[uint64]Position) // tokenId -> Position
	nextId    uint64              = 1                         // lp token id
)

// nextId is the next tokenId to be minted
func getNextId() uint64 {
	return nextId
}

// PositionOperation defines the interface fort all position-related operations.
// Each operation must implement `Validate()` and `Process()` methods.
type PositionOperation interface {
	// Validate checks if the operation parameters are valid (wrapper for assert functions).
	// Returns an error/panic if validation fails.
	Validate() error

	// Process executes the core logic of the operation.
	// Returns an `OperationResult` containing all relevant data from the operation.
	Process() (*OperationResult, error)
}

// OperationResult encapsulates the outcomes of a successful mint operation.
// it includes all relavant position details and amounts.
//
// TODO (@notJoon): change type name to `MintResult`
type OperationResult struct {
	TokenId   uint64
	Liquidity *u256.Uint
	Amount0   *u256.Uint
	Amount1   *u256.Uint
	Fee0      *u256.Uint
	Fee1      *u256.Uint
	PoolPath  string
	TickLower int32
	TickUpper int32
}

// baseOperation handler
func executeOperation(op PositionOperation) (*OperationResult, error) {
	common.IsHalted()
	en.MintAndDistributeGns()

	// validate operation
	if err := op.Validate(); err != nil {
		return nil, err
	}

	result, err := op.Process()
	if err != nil {
		return nil, err
	}

	// emiot event after execution
	return result, nil
}

///////////////// MINT ///////////////////
// region: mint

// Mint creates a new liquidity position with the specified parameters.
// This is the main public interface for creating positions.
// It handles both normal token pairs and pairs involving the native token.
//
// Parameters:
//   - token0, token1: Addresses of the tokens in the pair
//   - fee: The fee tier for the pool
//   - tickLower, tickUpper: Price range boundaries in tick form
//   - amount0Desired, amount1Desired: Desired token amounts to deposit
//   - amount0Min, amount1Min: Minimum acceptable amounts (slippage protection)
//   - deadline: Transaction timeout timestamp
//   - mintTo: Recipient address for the position token
//   - caller: Transaction initiator address
//
// Returns:
//   - tokenId: Unique identifier for the minted position
//   - liquidity: Amount of liquidity tokens minted
//   - amount0, amount1: Actual amounts of tokens deposited
//
// May panic with:
//   - errInvalidInput: If input validation fails
//   - errProcessing: If the mint operation fails
//
// for more details, see: https://docs.gnoswap.io/contracts/position/position.gno#mint
func Mint(
	token0, token1 string,
	fee uint32,
	tickLower, tickUpper int32,
	amount0Desired, amount1Desired string,
	amount0Min, amount1Min string,
	deadline int64,
	mintTo, caller std.Address,
) (uint64, string, string, string) {
	input := MintInput{
		token0:         token0,
		token1:         token1,
		fee:            fee,
		tickLower:      tickLower,
		tickUpper:      tickUpper,
		amount0Desired: amount0Desired,
		amount1Desired: amount1Desired,
		amount0Min:     amount0Min,
		amount1Min:     amount1Min,
		deadline:       deadline,
		mintTo:         mintTo,
		caller:         caller,
	}

	op := NewMintOperation(input)
	result, err := executeOperation(op)
	if err != nil {
		panic(err)
	}

	prevAddr, prevPkgPath := getPrevAsString()
	poolSqrtPriceX96 := pl.PoolGetSlot0SqrtPriceX96(result.PoolPath)

	std.Emit(
		"Mint",
		"prevAddr", prevAddr,
		"prevRealm", prevPkgPath,
		"tickLower", ufmt.Sprintf("%d", result.TickLower),
		"tickUpper", ufmt.Sprintf("%d", result.TickUpper),
		"poolPath", result.PoolPath,
		"caller", op.input.caller.String(),
		"internal_lpTokenId", ufmt.Sprintf("%d", result.TokenId),
		"internal_liquidity", result.Liquidity.ToString(),
		"internal_amount0", result.Amount0.ToString(),
		"internal_amount1", result.Amount1.ToString(),
		"internal_sqrtPriceX96", poolSqrtPriceX96,
	)

	return result.TokenId, result.Liquidity.ToString(), result.Amount0.ToString(), result.Amount1.ToString()
}

// MintOperation encasulates the logic for creating a new liquidity position.
// it handles input validation, position creation, and token transfers.
type MintOperation struct {
	input          MintInput
	processedInput *ProcessedMintInput
}

// NewMintOperation creates a new instance of MintOperation with the given input parameters.
// It initializes the operation without processing the input data.
func NewMintOperation(input MintInput) *MintOperation {
	return &MintOperation{input: input}
}

// MintInput represents all necessary parameters for creating a new liquidity position.
// All values are passes are as strings to eradiacate original value pollution (especially large amounts)..
type MintInput struct {
	// Token addresses for the pool pair
	token0         string
	token1         string

	// fee tier for the pool (e.g., 0.3% = 3000)
	fee            uint32

	// Price range boundaries in tick form
	tickLower      int32
	tickUpper      int32

	// Desired amounts of tokens to deposit
	amount0Desired string
	amount1Desired string

	// Minimum amounts to prevent excessive slippage
	amount0Min     string
	amount1Min     string

	// Transaction deadline timestamp
	deadline       int64

	// Address to receive the LP token
	mintTo         std.Address

	// Transaction initiator (or, caller) address
	caller         std.Address
}

type TokenPair struct {
	token0         string
	token1         string
	token0IsNative bool
	token1IsNative bool
}

type ProcessedMintInput struct {
	tokenPair      TokenPair
	amount0Desired *u256.Uint
	amount1Desired *u256.Uint
	amount0Min     *u256.Uint
	amount1Min     *u256.Uint
	tickLower      int32
	tickUpper      int32
	poolPath       string
}

// Validate performs all necessary checks on the mint input parameters.
//
// It verifies:
//  - Caller permission
//  - Token pair validity
//  - Price range validity
//  - Amounts validity
//
// Returns an error or panic if any of the checks fail.
func (op *MintOperation) Validate() error {
	assertCallerPermission(std.PrevRealm())

	processedInput, err := processMintInput(op.input)
	if err != nil {
		return err
	}

	op.processedInput = &processedInput

	return nil
}

// Process executes the mint operation after validation.
//
// It handles:
//  - Token transfers and wrapping/unwrapping of native tokens
//  - Liquidity position creation
//  - Position token minting
//
// Returns the operation result or an error if the process fails.
func (op *MintOperation) Process() (*OperationResult, error) {
	// Track initial WUGNOT balance
	usrWugnotBalance := wugnot.BalanceOf(a2u(op.input.caller))

	// handle native token conversion if needed
	if err := handleNativeToken(
		op.processedInput.tokenPair.token0IsNative,
		op.processedInput.tokenPair.token1IsNative,
		op.input.caller,
	); err != nil {
		return nil, err
	}

	// create mint params and execute mint
	mintParams := newMintParams(*op.processedInput, op.input)
	tokenId, liquidity, amount0, amount1 := mint(mintParams)

	// handle leftover native token
	// TODO (@notJoon): Are there any cases where this function shouldn't be called?
	handleLeftoverNativeToken(
		op.processedInput.tokenPair.token0IsNative,
		op.processedInput.tokenPair.token1IsNative,
		usrWugnotBalance,
		op.input.caller,
	)

	return &OperationResult{
		TokenId:   tokenId,
		Liquidity: liquidity,
		Amount0:   amount0,
		Amount1:   amount1,
		PoolPath:  op.processedInput.poolPath,
		TickLower: op.processedInput.tickLower,
		TickUpper: op.processedInput.tickUpper,
	}, nil
}

func mint(params MintParams) (uint64, *u256.Uint, *u256.Uint, *u256.Uint) {
	checkDeadline(params.deadline)

	pool := pl.GetPool(params.token0, params.token1, params.fee)
	liquidity, amount0, amount1, err := addLiquidity(
		AddLiquidityParams{
			poolKey:        pl.GetPoolPath(params.token0, params.token1, params.fee),
			tickLower:      params.tickLower,
			tickUpper:      params.tickUpper,
			amount0Desired: params.amount0Desired,
			amount1Desired: params.amount1Desired,
			amount0Min:     params.amount0Min,
			amount1Min:     params.amount1Min,
			caller:         params.caller,
		},
	)
	if err != nil {
		panic(addDetailToError(errSlippage, err.Error()))
	}

	tokenId := nextId
	gnft.Mint(a2u(params.mintTo), tokenIdFrom(tokenId)) // owner, tokenId
	nextId++

	/* State Update */

	positionKey := positionKeyCompute(GetOrigPkgAddr(), params.tickLower, params.tickUpper)
	feeGrowthInside0LastX128 := pool.PositionFeeGrowthInside0LastX128(positionKey)
	feeGrowthInside1LastX128 := pool.PositionFeeGrowthInside1LastX128(positionKey)

	position := Position{
		nonce:                    u256.Zero(),
		operator:                 consts.ZERO_ADDRESS,
		poolKey:                  pl.GetPoolPath(params.token0, params.token1, params.fee),
		tickLower:                params.tickLower,
		tickUpper:                params.tickUpper,
		liquidity:                liquidity,
		feeGrowthInside0LastX128: feeGrowthInside0LastX128,
		feeGrowthInside1LastX128: feeGrowthInside1LastX128,
		tokensOwed0:              u256.Zero(),
		tokensOwed1:              u256.Zero(),
		burned:                   false,
	}
	positions[tokenId] = position

	return tokenId, liquidity, amount0, amount1
}

///////////////// INCREASE LIQUIDITY ///////////////////
// region: increaseLiquidity

// IncreaseLiquidity represents the parameters needed to add liquidity to an existing position.
type IncreaseLiquidityInput struct {
	// Unique identifier of the existing position.
	// this data comes from the `position` type.
	TokenId        uint64

	// Additional amounts to deposit
	Amount0Desired *u256.Uint
	Amount1Desired *u256.Uint

	// Minimum acceptable amounts (slippage protection)
    Amount0Min     *u256.Uint
    Amount1Min     *u256.Uint

	// Transaction deadline timestamp
    Deadline       int64
}

// IncreaseLiquidityResult encapsulates the outcome of a liquidity increase operation.
func IncreaseLiquidity(
    tokenId uint64,
    amount0Desired string,
    amount1Desired string,
    amount0Min string,
    amount1Min string,
    deadline int64,
) (uint64, string, string, string, string) {
	input := IncreaseLiquidityInput{
		TokenId: tokenId,
		Amount0Desired: u256.MustFromDecimal(amount0Desired),
		Amount1Desired: u256.MustFromDecimal(amount1Desired),
		Amount0Min: u256.MustFromDecimal(amount0Min),
		Amount1Min: u256.MustFromDecimal(amount1Min),
		Deadline: deadline,
	}

	op := NewIncreaseLiquidityOperation(input)

	if err := op.Validate(); err != nil {
		panic(addDetailToError(errInvalidInput, err.Error()))
	}

	result, err := op.Process()
	if err != nil {
		panic(err)
	}

	prevAddr, prevPkgPath := getPrevAsString()

	std.Emit(
        "IncreaseLiquidity",
        "prevAddr", prevAddr,
        "prevRealm", prevPkgPath,
        "lpTokenId", ufmt.Sprintf("%d", result.TokenId),
        "internal_poolPath", result.PoolPath,
        "internal_liquidity", result.Liquidity.ToString(),
        "internal_amount0", result.Amount0.ToString(),
        "internal_amount1", result.Amount1.ToString(),
        "internal_sqrtPriceX96", pl.PoolGetSlot0SqrtPriceX96(result.PoolPath),
    )

	return result.TokenId, result.Liquidity.ToString(), result.Amount0.ToString(), result.Amount1.ToString(), result.PoolPath
}

// IncreaseLiquidityResult contains the outcome of an increase liquidity operation.
// It provides detailed information about the liquidity added and tokens used.
type IncreaseLiquidityResult struct {
	// Position identifier
	TokenId    		uint64

	// Additional liquidity minted
	Liquidity  		*u256.Uint

	// Actual amounts of tokens deposited
	Amount0    		*u256.Uint
	Amount1    		*u256.Uint

	// pool path
	PoolPath  		string
}

// IncreaseLiquidityOperation represents the increase liquidity operation.
// It handles the validation and execution of adding liquidity to an existing position.
type IncreaseLiquidityOperation struct {
	// input contains the parameters for the increase operation
    input     		IncreaseLiquidityInput

	// position holds the current state of the position being modified
    position  		Position
}

// NewIncreaseLiquidityOperation creates a new instance of IncreaseLiquidityOperation.
// It initializes the operation with the provided input parameters.
//
// Parameters:
//   - input: The increase liquidity parameters
//
// Returns:
//   - *IncreaseLiquidityOperation: A new operation instance
func NewIncreaseLiquidityOperation(input IncreaseLiquidityInput) *IncreaseLiquidityOperation {
    return &IncreaseLiquidityOperation{input: input}
}

// Validate performs validation checks on the increase liquidity operation.
// It ensures the operation can be executed safely and the caller has proper permissions.
//
// Checks performed:
//   - Position exists
//   - Caller owns the position token
//   - Position is not burned
//
// Returns:
//   - error: nil if validation passes, error otherwise
func (op *IncreaseLiquidityOperation) Validate() error {
	position, exists := positions[op.input.TokenId]
	if !exists {
		return ufmt.Errorf("position %d not found", op.input.TokenId)
	}
	op.position = position

	assertTokenOwnership(op.input.TokenId)

	return nil
}

// Process executes the increase liquidity operation after validation.
// It handles the core logic of adding liquidity and updating the position state.
//
// Steps performed:
//   1. Tracks initial WUGNOT balance if native token is involved
//   2. Adds the new liquidity to the pool
//   3. Calculates and updates fee growth tracking
//   4. Updates position state with new liquidity and fee data
//   5. Handles native token unwrapping if needed
//
// Returns:
//   - *IncreaseLiquidityResult: The operation results
//   - error: Any errors that occurred during processing
func (op *IncreaseLiquidityOperation) Process() (*IncreaseLiquidityResult, error) {
	// get initial WUGNOT balance
	userOldWugnotBalance := wugnot.BalanceOf(a2u(std.PrevRealm().Addr()))

	// handle native token if needed
	// TODO (@notJoon): Extract this logic to a separate function
	pToken0, pToken1, _ := splitOf(op.position.poolKey)
	isToken0Wugnot := pToken0 == consts.WRAPPED_WUGNOT
	isToken1Wugnot := pToken1 == consts.WRAPPED_WUGNOT

	if hasWugnotToken(isToken0Wugnot, isToken1Wugnot) {
		sent := std.GetOrigSend()
		ugnotSent := uint64(sent.AmountOf("ugnot"))

		assertWrapNativeToken(ugnotSent, std.PrevRealm().Addr())
	}

	liqParams := AddLiquidityParams{
        poolKey:        op.position.poolKey,
        tickLower:      op.position.tickLower,
        tickUpper:      op.position.tickUpper,
        amount0Desired: op.input.Amount0Desired,
        amount1Desired: op.input.Amount1Desired,
        amount0Min:     op.input.Amount0Min,
        amount1Min:     op.input.Amount1Min,
        caller:         std.PrevRealm().Addr(),
    }

	liquidity, amount0, amount1, err := addLiquidity(liqParams)
	if err != nil {
		return nil, err
	}

	pool := pl.GetPoolFromPoolPath(op.position.poolKey)
	positionKey := positionKeyCompute(GetOrigPkgAddr(), op.position.tickLower, op.position.tickUpper)

	currentFeeGrowth := FeeGrowthInside{
		feeGrowthInside0LastX128: pool.PositionFeeGrowthInside0LastX128(positionKey),
		feeGrowthInside1LastX128: pool.PositionFeeGrowthInside1LastX128(positionKey),
	}

	feeUpdate := calculatePositionFeeUpdate(op.position, currentFeeGrowth)
	updatedPosition := updatePosition(op.position, feeUpdate, liquidity)

	positions[op.input.TokenId] = updatedPosition

	if hasWugnotToken(isToken0Wugnot, isToken1Wugnot) {
		usrNewWugnotBalance := wugnot.BalanceOf(a2u(std.PrevRealm().Addr()))
		leftover := usrNewWugnotBalance - userOldWugnotBalance
		unwrap(leftover, std.PrevRealm().Addr())
	}

	return &IncreaseLiquidityResult{
		TokenId: op.input.TokenId,
		Liquidity: liquidity,
		Amount0: amount0,
		Amount1: amount1,
		PoolPath: op.position.poolKey,
	}, nil
}

// FeeGrowthInside represents fee growth inside ticks
type FeeGrowthInside struct {
	feeGrowthInside0LastX128 *u256.Uint
	feeGrowthInside1LastX128 *u256.Uint
}

// PositionFeeUpdate represents fee update calculation result
type PositionFeeUpdate struct {
	tokensOwed0 *u256.Uint
	tokensOwed1 *u256.Uint
	feeGrowthInside0LastX128 *u256.Uint
	feeGrowthInside1LastX128 *u256.Uint
}

// calculateTokensOwed determines the amount of fees owed based on fee growth and liquidity.
//
// Parameters:
//   - currentFeeGrowth: Current cumulative fee growth
//   - lastFeeGrowth: Last recorded fee growth for the position
//   - liquidity: Amount of liquidity for fee calculation
//
// Returns:
//   - *u256.Uint: Amount of tokens owed as fees
func calculatePositionFeeUpdate(
	position Position,
	currentFeeGrowth FeeGrowthInside,
) PositionFeeUpdate {
	tokensOwed0 := calculateTokensOwed(
		currentFeeGrowth.feeGrowthInside0LastX128,
		position.feeGrowthInside0LastX128,
		position.liquidity,
	)

	tokensOwed1 := calculateTokensOwed(
		currentFeeGrowth.feeGrowthInside1LastX128,
		position.feeGrowthInside1LastX128,
		position.liquidity,
	)

	return PositionFeeUpdate{
		tokensOwed0:              new(u256.Uint).Add(position.tokensOwed0, tokensOwed0),
		tokensOwed1:              new(u256.Uint).Add(position.tokensOwed1, tokensOwed1),
		feeGrowthInside0LastX128: currentFeeGrowth.feeGrowthInside0LastX128.Clone(),
		feeGrowthInside1LastX128: currentFeeGrowth.feeGrowthInside1LastX128.Clone(),
	}
}

func calculateTokensOwed(
	currentFeeGrowth *u256.Uint,
	lastFeeGrowth *u256.Uint,
	liquidity *u256.Uint,
) *u256.Uint {
	diff := new(u256.Uint).Sub(currentFeeGrowth, lastFeeGrowth)
	return u256.MulDiv(diff, liquidity, u256.MustFromDecimal(consts.Q128))
}

func updateTokensOwed(
	feeGrowthInsideLastX128 *u256.Uint,
	positionFeeGrowthInsideLastX128 *u256.Uint,
	positionLiquidity *u256.Uint,
	burnedAmount *u256.Uint,
	tokensOwed *u256.Uint,
) *u256.Uint {
	additionalTokensOwed := calculateTokensOwed(feeGrowthInsideLastX128, positionFeeGrowthInsideLastX128, positionLiquidity)
	add := new(u256.Uint).Add(burnedAmount, additionalTokensOwed)
	return new(u256.Uint).Add(tokensOwed, add)
}

// updatePosition updates the position state with new liquidity and fee data.
//
// Parameters:
//   - position: Current position state
//   - feeUpdate: New fee data to apply
//   - newLiquidity: Additional liquidity being added
//
// Returns:
//   - Position: Updated position state
//
// The function applies the fee updates and adds the new liquidity while maintaining
// the position's other properties.
func updatePosition(
	position Position,
	feeUpdate PositionFeeUpdate,
	newLiquidity *u256.Uint,
) Position {
	position.tokensOwed0 = feeUpdate.tokensOwed0
	position.tokensOwed1 = feeUpdate.tokensOwed1
	position.feeGrowthInside0LastX128 = feeUpdate.feeGrowthInside0LastX128
	position.feeGrowthInside1LastX128 = feeUpdate.feeGrowthInside1LastX128
	position.liquidity = new(u256.Uint).Add(position.liquidity, newLiquidity)
	position.burned = false

	return position
}

///////////////// DECREASE LIQUIDITY ///////////////////
// region: decreaseLiquidity

// DecreaseLiquidity represents the parameters needed to reduce liquidity from an existing position.
func DecreaseLiquidity(
    tokenId uint64,
    liquidityRatio uint64,
    amount0Min string,
    amount1Min string,
    deadline int64,
    unwrapResult bool,
) (uint64, string, string, string, string, string, string) {
	common.IsHalted()
	en.MintAndDistributeGns()

	input := DecreaseLiquidityInput{
		TokenId: tokenId,
		LiquidityRatio: liquidityRatio,
		Amount0Min: u256.MustFromDecimal(amount0Min),
		Amount1Min: u256.MustFromDecimal(amount1Min),
		Deadline: deadline,
		Unwrap: unwrapResult,
	}

	op := NewDecreaseLiquidityOperation(input)

	if err := op.Validate(); err != nil {
		panic(addDetailToError(errInvalidInput, err.Error()))
	}

	result, err := op.Process()
	if err != nil {
		panic(err)
	}

	prevAddr, prevPkgPath := getPrevAsString()

	std.Emit(
        "decreaseLiquidity",
        "prevAddr", prevAddr,
        "prevRealm", prevPkgPath,
        "lpTokenId", ufmt.Sprintf("%d", result.TokenId),
        "internal_poolPath", result.PoolPath,
        "internal_liquidity", result.Liquidity.ToString(),
        "internal_amount0", result.Amount0.ToString(),
        "internal_amount1", result.Amount1.ToString(),
        "internal_sqrtPriceX96", pl.PoolGetSlot0SqrtPriceX96(result.PoolPath),
    )

	return result.TokenId, result.Liquidity.ToString(), result.Fee0.ToString(), result.Fee1.ToString(), result.Amount0.ToString(), result.Amount1.ToString(), result.PoolPath
}

// DecreaseLiquidityInput encapsulates the parameters required for reducing a position's liquidity.
// It contains all necessary information to safely remove liquidity from an existing position.
type DecreaseLiquidityInput struct {
	// TokenId uniquely identifies the position to be decrease liquidity from
    TokenId         uint64

	// LiquidityRatio represents the percentage (1-100) of liquidity 
    LiquidityRatio  uint64

	// Amount0Min and Amount1Min specify the minimum acceptable token amounts
    // to protect against price slippage during the decrease operation
    Amount0Min      *u256.Uint
    Amount1Min      *u256.Uint

	// Deadline specifies the timestamp by which the transaction must be executed
    Deadline        int64

	// Unwrap determines whether native tokens should be unwrapped after
    // the liquidity decrease operation
    Unwrap          bool
}

// DecreaseLiquidityResult contains the outcome of a decrease liquidity operation.
// It provides comprehensive information about the amounts of tokens and fees involved.
type DecreaseLiquidityResult struct {
	// TokenId identifies the affected position
    TokenId         uint64

	// Liquidity represents the amount of liquidity removed from the position
    Liquidity       *u256.Uint

	// Fee0 and Fee1 represent the accumulated fees collected during the operation
    Fee0       		*u256.Uint
    Fee1      		*u256.Uint

	// Amount0 and Amount1 represent the actual amounts of tokens withdrawn
    Amount0    		*u256.Uint
    Amount1    		*u256.Uint

	// PoolPath identifies the pool where the operation occurred
    PoolPath  		string
}

// DecreaseLiquidityOperation represents the decrease liquidity operation.
// It handles the validation and execution of liquidity removal from a position.
type DecreaseLiquidityOperation struct {
	// input contains the parameters for the decrease operation
    input     		DecreaseLiquidityInput

	// position holds the current state of the position being modified
    position  		Position
}

// NewDecreaseLiquidityOperation creates a new instance of DecreaseLiquidityOperation.
// It initializes the operation with the provided input parameters.
//
// Parameters:
//   - input: The decrease liquidity parameters
//
// Returns:
//   - *DecreaseLiquidityOperation: A new operation instance
func NewDecreaseLiquidityOperation(input DecreaseLiquidityInput) *DecreaseLiquidityOperation {
    return &DecreaseLiquidityOperation{input: input}
}

// Validate performs validation checks on the decrease liquidity operation.
// It ensures all parameters are valid and the operation can be executed safely.
//
// Checks performed:
//   - LiquidityRatio is between 1 and 100
//   - Position exists and has liquidity
//   - Caller has permission to modify the position
//
// Returns:
//   - error: nil if validation passes, error otherwise
func (op *DecreaseLiquidityOperation) Validate() error {
	// check range
	if op.input.LiquidityRatio < 1 || op.input.LiquidityRatio > MAX_RATIO {
		return ufmt.Errorf("liquidity ratio must be between 1 and 100")
	}

	tokenId := op.input.TokenId

	position, exists := positions[tokenId]
	if !exists {
		return ufmt.Errorf("position %d not found", tokenId)
	}
	op.position = position

	if op.position.liquidity.IsZero() {
		return ufmt.Errorf("position(tokenId: %d) has no liquidity", op.input.TokenId)
	}

	verifyTokenIdAndOwnership(tokenId)

	return nil
}

// Process executes the decrease liquidity operation after validation.
// It handles the core logic of removing liquidity and collecting fees.
//
// Steps performed:
//   1. Collects any accumulated fees
//   2. Calculates the amount of liquidity to remove
//   3. Burns the specified amount of liquidity
//   4. Updates position state
//   5. Handles native token unwrapping if requested
//
// Returns:
//   - *DecreaseLiquidityResult: The operation results
//   - error: Any errors that occurred during processing
func (op *DecreaseLiquidityOperation) Process() (*DecreaseLiquidityResult, error) {
	userOldWugnotBalance := wugnot.BalanceOf(a2u(std.PrevRealm().Addr()))

	_, fee0Str, fee1Str, _, _, _ := CollectFee(op.input.TokenId, op.input.Unwrap)
	fee0 := u256.MustFromDecimal(fee0Str)
	fee1 := u256.MustFromDecimal(fee1Str)

	liquidityToRemove := calculateLiquidityToRemove(op.position.liquidity, op.input.LiquidityRatio)

	pToken0, pToken1, pFee := splitOf(op.position.poolKey)
	burned0, burned1 := pl.Burn(pToken0, pToken1, pFee, op.position.tickLower, op.position.tickUpper, liquidityToRemove.ToString())

	burnedAmount0 := u256.MustFromDecimal(burned0)
	burnedAmount1 := u256.MustFromDecimal(burned1)

	verifyBurnedAmounts(burnedAmount0, burnedAmount1, op.input.Amount0Min, op.input.Amount1Min)

	pool := pl.GetPoolFromPoolPath(op.position.poolKey)
	positionKey := positionKeyCompute(GetOrigPkgAddr(), op.position.tickLower, op.position.tickUpper)

	// TODO: create New function
	currentFeeGrowth := FeeGrowthInside{
		feeGrowthInside0LastX128: pool.PositionFeeGrowthInside0LastX128(positionKey),
		feeGrowthInside1LastX128: pool.PositionFeeGrowthInside1LastX128(positionKey),
	}

	op.position.tokensOwed0 = updateTokensOwed(
		currentFeeGrowth.feeGrowthInside0LastX128,
		op.position.feeGrowthInside0LastX128,
		op.position.liquidity,
		burnedAmount0,
		op.position.tokensOwed0,
	)

	op.position.tokensOwed1 = updateTokensOwed(
		currentFeeGrowth.feeGrowthInside1LastX128,
		op.position.feeGrowthInside1LastX128,
		op.position.liquidity,
		burnedAmount1,
		op.position.tokensOwed1,
	)

	// update position fields
	op.position.liquidity = new(u256.Uint).Sub(op.position.liquidity, liquidityToRemove)
    op.position.feeGrowthInside0LastX128 = currentFeeGrowth.feeGrowthInside0LastX128
    op.position.feeGrowthInside1LastX128 = currentFeeGrowth.feeGrowthInside1LastX128

	collectedAmount0, collectedAmount1 := pl.Collect(
		pToken0, pToken1, pFee,
		std.PrevRealm().Addr(),
		op.position.tickLower, op.position.tickUpper,
		burned0, burned1,
	)

	amount0 := u256.MustFromDecimal(collectedAmount0)
	amount1 := u256.MustFromDecimal(collectedAmount1)

	// Update tokens owed
	overflow := false
    op.position.tokensOwed0, overflow = new(u256.Uint).SubOverflow(op.position.tokensOwed0, amount0)
	if overflow {
		op.position.tokensOwed0 = u256.Zero()
	}

    op.position.tokensOwed1, overflow = new(u256.Uint).SubOverflow(op.position.tokensOwed1, amount1)
	if overflow {
		op.position.tokensOwed1 = u256.Zero()
	}

	positions[op.input.TokenId] = op.position

	if op.position.isClear() {
		burnPosition(op.input.TokenId)
	}

	if op.input.Unwrap {
		handleUnwrap(pToken0, pToken1, op.input.Unwrap, userOldWugnotBalance, std.PrevRealm().Addr())
	}

	return &DecreaseLiquidityResult{
		TokenId: op.input.TokenId,
		Liquidity: liquidityToRemove,
		Fee0: fee0,
		Fee1: fee1,
		Amount0: amount0,
		Amount1: amount1,
		PoolPath: op.position.poolKey,
	}, nil
}

// calculateLiquidityToRemove determines the amount of liquidity to remove based on
// the current position liquidity and the requested ratio.
//
// Parameters:
//   - positionLiquidity: Current liquidity in the position
//   - liquidityRatio: Percentage of liquidity to remove (1-100)
//
// Returns:
//   - *u256.Uint: Amount of liquidity to remove
//
// Note: If liquidityRatio is 100 or the calculated amount exceeds position liquidity,
// the entire position liquidity is removed.
func calculateLiquidityToRemove(positionLiquidity *u256.Uint, liquidityRatio uint64) *u256.Uint {
	liquidityToRemove := new(u256.Uint).Mul(positionLiquidity, u256.NewUint(liquidityRatio))
	liquidityToRemove = new(u256.Uint).Div(liquidityToRemove, u256.NewUint(MAX_RATIO))

	if positionLiquidity.Lt(liquidityToRemove) || liquidityRatio == MAX_RATIO {
		return positionLiquidity
	}

	return liquidityToRemove
}

// burnPosition marks a position as burned when it no longer has any remaining liquidity
// or uncollected fees.
func burnPosition(tokenId uint64) {
	position := positions[tokenId]
	checkPositionHasClear(position)

	position.burned = true
	positions[tokenId] = position
}

// handleUnwrap manages the unwrapping of native tokens after a decrease liquidity operation.
//
// The function calculates the difference in WUGNOT balance and unwraps any excess
// back to native tokens if requested.
func handleUnwrap(pToken0, pToken1 string, unwrapResult bool, userOldWugnotBalance uint64, to std.Address) {
	if (pToken0 == consts.WRAPPED_WUGNOT || pToken1 == consts.WRAPPED_WUGNOT) && unwrapResult {
		userNewWugnotBalance := wugnot.BalanceOf(a2u(to))
		leftOver := userNewWugnotBalance - userOldWugnotBalance
		unwrap(leftOver, to)
	}
}

///////////////// CollectFee ///////////////////
// region: collectFee

// CollectFee collects accumulated fees from a liquidity position.
// This is the main entry point for fee collection in the protocol.
//
// Parameters:
//   - tokenId: The ID of the position to collect fees from
//   - unwrapResult: Whether to unwrap native tokens after collection
//
// Returns:
//   - tokenId: Position identifier
//   - fee0, fee1: Collected fee amounts after protocol fee
//   - poolPath: Pool identifier
//   - origFee0, origFee1: Original fee amounts before protocol fee
//
// Events emitted:
//   - CollectSwapFee: When fees are successfully collected
//
// The function handles both standard ERC20 fees and wrapped native token fees.
// It ensures proper calculation and distribution of protocol fees.
func CollectFee(tokenId uint64, unwrapResult bool) (uint64, string, string, string, string, string) {
	common.IsHalted()
	en.MintAndDistributeGns()

	input := CollectFeeInput{
		TokenId: tokenId,
		Unwrap: unwrapResult,
	}

	op := NewCollectFeeOperation(input)

	if err := op.Validate(); err != nil {
		panic(addDetailToError(errInvalidInput, err.Error()))
	}

	result, err := op.Process()
	if err != nil {
		panic(err)
	}

	prevAddr, prevPkgPath := getPrevAsString()

	std.Emit(
        "CollectSwapFee",
        "prevAddr", prevAddr,
        "prevRealm", prevPkgPath,
        "lpTokenId", ufmt.Sprintf("%d", result.TokenId),
        "internal_fee0", result.Fee0.ToString(),
        "internal_fee1", result.Fee1.ToString(),
        "internal_poolPath", result.PoolPath,
        "internal_unwrapResult", ufmt.Sprintf("%t", op.input.Unwrap),
    )

	return result.TokenId, result.Fee0.ToString(), result.Fee1.ToString(), result.PoolPath, result.OrigFee0, result.OrigFee1
}

// CollectFeeInput encapsulates the parameters needed to collect accumulated fees
// from a liquidity position. It provides the necessary information to identify
// the position and handle native token unwrapping.
type CollectFeeInput struct {
	// TokenId uniquely identifies the position to collect fees from
    TokenId       uint64

	// Unwrap determines whether native tokens should be unwrapped
    // after fee collection. This is relevant when one of the tokens
    // in the pool is the wrapped native token (WUGNOT).
    Unwrap  bool
}

// CollectFeeResult contains the outcome of a fee collection operation.
// It provides detailed information about the collected fees and their origin.
type CollectFeeResult struct {
	// TokenId identifies the position fees were collected from
    TokenId    uint64

	// Fee0 and Fee1 represent the amounts of collected fees for each token
    // after protocol fee deduction
    Fee0       *u256.Uint
    Fee1       *u256.Uint

	// PoolPath identifies the pool where the fees were collected
    PoolPath   string

	// OrigFee0 and OrigFee1 represent the original amounts of fees before
    // protocol fee deduction
    OrigFee0   string
    OrigFee1   string
}

// CollectFeeOperation represents the fee collection operation.
// It handles the validation and execution of collecting accumulated fees
// from a liquidity position.
type CollectFeeOperation struct {
	// input contains the parameters for the fee collection.
    input     	CollectFeeInput

	// position holds the current state of the position being modified
    position  	Position
}

// NewCollectFeeOperation creates a new instance of CollectFeeOperation.
// It initializes the operation with the provided input parameters.
//
// Parameters:
//   - input: The fee collection parameters
//
// Returns:
//   - *CollectFeeOperation: A new operation instance
func NewCollectFeeOperation(input CollectFeeInput) *CollectFeeOperation {
    return &CollectFeeOperation{ input: input }
}

// Validate performs validation checks on the fee collection operation.
// It ensures the operation can be executed safely and the caller has proper permissions.
//
// Checks performed:
//   - Position exists
//   - Caller is authorized to collect fees
//   - Position is not burned
//
// Returns:
//   - error: nil if validation passes, error otherwise
func (op *CollectFeeOperation) Validate() error {
	assertTokenExists(op.input.TokenId)
	isAuthorizedForToken(op.input.TokenId)

	// get and verify position
	position, exists := positions[op.input.TokenId]
	if !exists {
		return ufmt.Errorf("position(tokenId: %d) not found", op.input.TokenId)
	}
	op.position = position

	return nil
}

// Process executes the fee collection operation after validation.
// It handles the core logic of collecting fees and updating position state.
//
// Steps performed:
//   1. Tracks initial WUGNOT balance if native token unwrap is requested
//   2. Updates fees by performing a zero-liquidity burn
//   3. Calculates current fee growth and collectable amounts
//   4. Collects fees from the pool
//   5. Updates position state
//   6. Handles protocol fee deduction
//   7. Unwraps native tokens if requested
//
// Returns:
//   - *CollectFeeResult: The operation results
//   - error: Any errors that occurred during processing
func (op *CollectFeeOperation) Process() (*CollectFeeResult, error) {
	token0, token1, fee := splitOf(op.position.poolKey)

	prevRealmAddr := std.PrevRealm().Addr()

	// check initial WUGNOT balance for potential unwrap
	userWugnot := wugnot.BalanceOf(a2u(prevRealmAddr))

	// burn with zero liquidity to update fees
	pl.Burn(
		token0, token1, fee,
		op.position.tickLower, op.position.tickUpper,
		ZERO_LIQUIDITY_FOR_FEE_COLLECTION,
	)

	// get current fee growth
	currentFeeGrowth, err := getCurrentFeeGrowth(op.position, token0, token1, fee)
	if err != nil {
		return nil, err
	}

	tokensOwed0, tokensOwed1 := calculateFees(op.position, currentFeeGrowth)

	amount0, amount1 := pl.Collect(
		token0, token1, fee,
		prevRealmAddr,
		op.position.tickLower, op.position.tickUpper,
		tokensOwed0.ToString(), tokensOwed1.ToString(),
	)

	// sometimes there will be a few less uBase amount than expected due to rounding down in core, but we just subtract the full amount expected
	// instead of the actual amount so we can burn the token
	op.position.tokensOwed0 = new(u256.Uint).Sub(tokensOwed0, u256.MustFromDecimal(amount0))
    op.position.tokensOwed1 = new(u256.Uint).Sub(tokensOwed1, u256.MustFromDecimal(amount1))
    positions[op.input.TokenId] = op.position

	// handle withdrawal fee
	withoutFee0, withoutFee1 := pl.HandleWithdrawalFee(
		op.input.TokenId,
		token0, amount0,
		token1, amount1,
		op.position.poolKey,
		prevRealmAddr,
	)

	// handle WUGNOT unwrap if needed
	if op.input.Unwrap {
		pToken0, pToken1, _ := splitOf(op.position.poolKey)
		if pToken0 == consts.WUGNOT_PATH || pToken1 == consts.WUGNOT_PATH {
            userNewWugnot := wugnot.BalanceOf(a2u(prevRealmAddr))
            unwrapAmount := userNewWugnot - userWugnot

            if unwrapAmount > 0 {
                unwrap(unwrapAmount, std.PrevRealm().Addr())
            }
        }
	}

	return &CollectFeeResult{
        TokenId:   op.input.TokenId,
        Fee0:      u256.MustFromDecimal(withoutFee0),
        Fee1:      u256.MustFromDecimal(withoutFee1),
        PoolPath:  op.position.poolKey,
        OrigFee0:  amount0,
        OrigFee1:  amount1,
    }, nil
}

// getCurrentFeeGrowth retrieves the current fee growth values from the pool
// for a specific position.
//
// Parameters:
//   - position: The position to get fee growth for
//   - token0, token1: Pool token addresses
//   - fee: Pool fee tier
//
// Returns:
//   - FeeGrowthInside: Current fee growth values
//   - error: Any errors during retrieval
//
// This function is used to calculate the fees accumulated since the last collection.
func getCurrentFeeGrowth(postion Position, token0, token1 string, fee uint32) (FeeGrowthInside, error) {
	pool := pl.GetPoolFromPoolPath(postion.poolKey)
	positionKey := positionKeyCompute(GetOrigPkgAddr(), postion.tickLower, postion.tickUpper)

	feeGrowthInside0 := pool.PositionFeeGrowthInside0LastX128(positionKey)
	feeGrowthInside1 := pool.PositionFeeGrowthInside1LastX128(positionKey)

	feeGrowthInside := FeeGrowthInside{
		feeGrowthInside0LastX128: feeGrowthInside0,
		feeGrowthInside1LastX128: feeGrowthInside1,
	}

	return feeGrowthInside, nil
}

// calculateFees computes the amount of fees that can be collected from a position.
// It uses the difference between current and last fee growth to determine uncollected fees.
//
// Parameters:
//   - position: Current position state
//   - currentFeeGrowth: Current fee growth values from the pool
//
// Returns:
//   - *u256.Uint: Token0 fees to collect
//   - *u256.Uint: Token1 fees to collect
//
// The calculation accounts for the position's liquidity and the fee growth
// inside the position's tick range.
func calculateFees(position Position, currentFeeGrowth FeeGrowthInside) (*u256.Uint, *u256.Uint) {
	fee0 := calculateTokensOwed(
		currentFeeGrowth.feeGrowthInside0LastX128,
		position.feeGrowthInside0LastX128,
		position.liquidity,
	)

	fee1 := calculateTokensOwed(
		currentFeeGrowth.feeGrowthInside1LastX128,
		position.feeGrowthInside1LastX128,
		position.liquidity,
	)

	tokensOwed0 := new(u256.Uint).Add(position.tokensOwed0.Clone(), fee0)
	tokensOwed1 := new(u256.Uint).Add(position.tokensOwed1.Clone(), fee1)

	return tokensOwed0, tokensOwed1
}

///////////////// Reposition ///////////////////
// region: reposition

// Reposition adjusts a position's price range by moving liquidity to a new range.
// This is the main entry point for repositioning liquidity in the protocol.
//
// Parameters:
//   - tokenId: The ID of the position to reposition
//   - tickLower, tickUpper: New price range boundaries
//   - amount0Desired, amount1Desired: Desired token amounts for the new position
//   - amount0Min, amount1Min: Minimum acceptable amounts for slippage protection
//
// Returns:
//   - tokenId: Position identifier
//   - liquidity: New liquidity amount
//   - tickLower, tickUpper: New price range boundaries
//   - amount0, amount1: Actual token amounts used
//
// Events emitted:
//   - Reposition: When liquidity is successfully repositioned
//
// The function ensures atomic execution of the reposition operation:
//   1. Validates the caller's ownership and position state
//   2. Moves liquidity to the new price range
//   3. Updates position state
//   4. Handles any native token conversions
//
// TODO (@notJoon): need to validate this function.
func Reposition(
    tokenId uint64,
    tickLower int32,
    tickUpper int32,
    amount0Desired string,
    amount1Desired string,
    amount0Min string,
    amount1Min string,
) (uint64, string, int32, int32, string, string) {
	common.IsHalted()
	en.MintAndDistributeGns()

	input := RepositionInput{
		TokenId: tokenId,
		TickLower: tickLower,
		TickUpper: tickUpper,
		Amount0Desired: u256.MustFromDecimal(amount0Desired),
		Amount1Desired: u256.MustFromDecimal(amount1Desired),
		Amount0Min: u256.MustFromDecimal(amount0Min),
		Amount1Min: u256.MustFromDecimal(amount1Min),
	}

	op := NewRepositionOperation(input)

	if err := op.Validate(); err != nil {
		panic(addDetailToError(errInvalidInput, err.Error()))
	}

	result, err := op.Process()
	if err != nil {
		panic(err)
	}

	prevAddr, prevPkgPath := getPrevAsString()
	poolSqrtPriceX96 := pl.PoolGetSlot0SqrtPriceX96(result.PoolPath)

	std.Emit(
        "Reposition",
        "prevAddr", prevAddr,
        "prevRealm", prevPkgPath,
        "lpTokenId", ufmt.Sprintf("%d", result.TokenId),
        "tickLower", ufmt.Sprintf("%d", result.TickLower),
        "tickUpper", ufmt.Sprintf("%d", result.TickUpper),
        "liquidity", result.Liquidity.ToString(),
        "internal_amount0", result.Amount0.ToString(),
        "internal_amount1", result.Amount1.ToString(),
        "internal_oldTickLower", ufmt.Sprintf("%d", result.OldTickLower),
        "internal_oldTickUpper", ufmt.Sprintf("%d", result.OldTickUpper),
        "internal_poolPath", result.PoolPath,
        "internal_sqrtPriceX96", poolSqrtPriceX96,
    )

	return result.TokenId, result.Liquidity.ToString(), result.TickLower, result.TickUpper, result.Amount0.ToString(), result.Amount1.ToString()
}

// RepositionInput encapsulates the parameters required for repositioning a liquidity position.
// It contains all necessary information to safely move liquidity to a new price range.
type RepositionInput struct {
	// TokenId uniquely identifies the position to be repositioned
    TokenId        uint64

	// TickLower and TickUpper define the new price range for the position
    TickLower      int32
    TickUpper      int32

	// Amount0Desired and Amount1Desired specify the desired amounts of tokens to add
    Amount0Desired *u256.Uint
    Amount1Desired *u256.Uint

	// Amount0Min and Amount1Min ensure the minimum amounts of tokens are met
    Amount0Min     *u256.Uint
    Amount1Min     *u256.Uint
}

// RepositionResult contains the outcome of a reposition operation.
// It provides comprehensive information about both the old and new position states.
type RepositionResult struct {
	// TokenId identifies the position being repositioned
    TokenId        uint64

	// Liquidity represents the new liquidity added to the position
    Liquidity      *u256.Uint

	// TickLower and TickUpper define the new price range for the position
    TickLower      int32
    TickUpper      int32

	// Amount0 and Amount1 represent the amounts of tokens added to the position
    Amount0        *u256.Uint
    Amount1        *u256.Uint

	// OldTickLower and OldTickUpper represent the old tick range of the position
    OldTickLower   int32
    OldTickUpper   int32

	// PoolPath identifies the pool where the reposition occurred
    PoolPath       string
}

// RepositionOperation represents the reposition operation.
// It handles the validation and execution of moving liquidity to a new price range.
type RepositionOperation struct {
	// input contains the parameters for the reposition operation
    input     RepositionInput

	// position holds the current state of the position being modified
    position  Position
}

// NewRepositionOperation creates a new instance of RepositionOperation.
// It initializes the operation with the provided input parameters.
//
// Parameters:
//   - input: The reposition parameters
//
// Returns:
//   - *RepositionOperation: A new operation instance
func NewRepositionOperation(input RepositionInput) *RepositionOperation {
    return &RepositionOperation{ input: input }
}

// Validate performs validation checks on the reposition operation.
// It ensures the operation can be executed safely and the caller has proper permissions.
//
// Checks performed:
//   - Caller owns the position token
//   - Position exists and is not burned
//   - Position has cleared any existing fees
//
// Returns:
//   - error: nil if validation passes, error otherwise
func (op *RepositionOperation) Validate() error {
	tokenId := op.input.TokenId
	assertTokenOwnership(tokenId)

	position, exists := positions[tokenId]
	if !exists {
		return ufmt.Errorf("position(tokenId: %d) not found", tokenId)
	}
	op.position = position

	checkPositionHasClear(op.position)

	return nil
}

// Process executes the reposition operation after validation.
// It handles the core logic of moving liquidity to a new price range.
//
// Steps performed:
//   1. Handles native token wrapping if needed
//   2. Adds liquidity to the new position range
//   3. Updates fee growth tracking
//   4. Updates position state with new price range and liquidity
//   5. Clears accumulated fees
//
// Returns:
//   - *RepositionResult: The operation results
//   - error: Any errors that occurred during processing
func (op *RepositionOperation) Process() (*RepositionResult, error) {
	poolKey := op.position.poolKey
	token0, token1, _ := splitOf(poolKey)

	// Check if GNOT pool
	// TODO (@notJoon): extract this to a helper function
    token0IsNative := token0 == consts.WRAPPED_WUGNOT
    token1IsNative := token1 == consts.WRAPPED_WUGNOT

	// Handle native token if needed
	if token0IsNative || token1IsNative {
		sent := std.GetOrigSend()
		ugnotSent := uint64(sent.AmountOf("ugnot"))

		assertWrapNativeToken(ugnotSent, std.PrevRealm().Addr())
    }

	liqParams := AddLiquidityParams{
        poolKey:        op.position.poolKey,
        tickLower:      op.input.TickLower,
        tickUpper:      op.input.TickUpper,
        amount0Desired: op.input.Amount0Desired,
        amount1Desired: op.input.Amount1Desired,
        amount0Min:     op.input.Amount0Min,
        amount1Min:     op.input.Amount1Min,
        caller:         std.PrevRealm().Addr(),
    }

	liquidity, amount0, amount1, err := addLiquidity(liqParams)
	if err != nil {
		return nil, ufmt.Errorf("%v: add liquidity failed", errSlippage)
	}

	pool := pl.GetPoolFromPoolPath(poolKey)
	positionKey := positionKeyCompute(GetOrigPkgAddr(), op.input.TickLower, op.input.TickUpper)

	feeGrowthInside0LastX128 := pool.PositionFeeGrowthInside0LastX128(positionKey)
    feeGrowthInside1LastX128 := pool.PositionFeeGrowthInside1LastX128(positionKey)

	/* Update State */

    // Store old ticks for event emission
    oldTickLower := op.position.tickLower
    oldTickUpper := op.position.tickUpper

    // Update position
    op.position.tickLower = op.input.TickLower
    op.position.tickUpper = op.input.TickUpper
    op.position.liquidity = liquidity
    op.position.feeGrowthInside0LastX128 = feeGrowthInside0LastX128
    op.position.feeGrowthInside1LastX128 = feeGrowthInside1LastX128
    op.position.tokensOwed0 = u256.Zero()
    op.position.tokensOwed1 = u256.Zero()
    op.position.burned = false

	positions[op.input.TokenId] = op.position

	return &RepositionResult{
        TokenId:      op.input.TokenId,
        Liquidity:    liquidity,
        TickLower:    op.input.TickLower,
        TickUpper:    op.input.TickUpper,
        Amount0:      amount0,
        Amount1:      amount1,
        OldTickLower: oldTickLower,
        OldTickUpper: oldTickUpper,
        PoolPath:     op.position.poolKey,
    }, nil
}

///////////////// HELPER ///////////////////
// region: helper

func assertCallerPermission(prev std.Realm) {
	isUserCalled := prev.PkgPath() == ""
	isStakerCalled := prev.Addr() == consts.STAKER_ADDR

	if !common.GetLimitCaller() {
		return
	}

	if !(isUserCalled || isStakerCalled) {
		panic(addDetailToError(
			errNoPermission,
			ufmt.Sprintf("only user or staker can call, but called from %s", prev.Addr().String()),
		))
	}
}

func processMintInput(input MintInput) (ProcessedMintInput, error) {
	var result ProcessedMintInput

	// process tokens
	token0, token1, token0IsNative, token1IsNative := processTokens(input.token0, input.token1)
	pair := TokenPair{
		token0:         token0,
		token1:         token1,
		token0IsNative: token0IsNative,
		token1IsNative: token1IsNative,
	}

	// parse amounts
	amount0Desired, amount1Desired, amount0Min, amount1Min := parseAmounts(input.amount0Desired, input.amount1Desired, input.amount0Min, input.amount1Min)

	tickLower, tickUpper := input.tickLower, input.tickUpper

	// swap if token1 < token0
	if token1 < token0 {
		pair.token0, pair.token1 = pair.token1, pair.token0
		amount0Desired, amount1Desired = amount1Desired, amount0Desired
		amount0Min, amount1Min = amount1Min, amount0Min
		tickLower, tickUpper = -tickUpper, -tickLower
		pair.token0IsNative, pair.token1IsNative = pair.token1IsNative, pair.token0IsNative
	}

	poolPath := renderPoolPath(pair.token0, pair.token1, input.fee)

	result = ProcessedMintInput{
		tokenPair:      pair,
		amount0Desired: amount0Desired.Clone(),
		amount1Desired: amount1Desired.Clone(),
		amount0Min:     amount0Min.Clone(),
		amount1Min:     amount1Min.Clone(),
		tickLower:      tickLower,
		tickUpper:      tickUpper,
		poolPath:       poolPath,
	}

	return result, nil
}

func processTokens(token0, token1 string) (string, string, bool, bool) {
	token0IsNative := false
	token1IsNative := false
	if token0 == consts.GNOT {
		token0 = consts.WRAPPED_WUGNOT
		token0IsNative = true
	} else if token1 == consts.GNOT {
		token1 = consts.WRAPPED_WUGNOT
		token1IsNative = true
	}
	return token0, token1, token0IsNative, token1IsNative
}

func parseAmounts(amount0Desired, amount1Desired, amount0Min, amount1Min string) (*u256.Uint, *u256.Uint, *u256.Uint, *u256.Uint) {
	return u256.MustFromDecimal(amount0Desired), u256.MustFromDecimal(amount1Desired), u256.MustFromDecimal(amount0Min), u256.MustFromDecimal(amount1Min)
}

func renderPoolPath(token0, token1 string, fee uint32) string {
	return ufmt.Sprintf("%s:%s:%d", token0, token1, fee)
}

func hasNativeToken(token0IsNative, token1IsNative bool) bool {
	return token0IsNative || token1IsNative
}

func handleNativeToken(token0IsNative, token1IsNative bool, caller std.Address) error {
	if !hasNativeToken(token0IsNative, token1IsNative) {
		return nil
	}

	oldUserWugnotBalance := wugnot.BalanceOf(a2u(caller))
	sent := std.GetOrigSend()
	ugnotSent := uint64(sent.AmountOf("ugnot"))

	if ugnotSent <= 0 {
		return nil
	}

	if err := wrap(ugnotSent, caller); err != nil {
		return err
	}

	newUserWugnotBalance := wugnot.BalanceOf(a2u(caller))
	diff := newUserWugnotBalance - oldUserWugnotBalance

	if diff != ugnotSent {
		return ufmt.Errorf("amount of ugnot (%d) is not equal to amount of wugnot. (diff: %d)", ugnotSent, diff)
	}

	return nil
}

func positionKeyCompute(
	owner std.Address,
	tickLower int32,
	tickUpper int32,
) string {
	key := ufmt.Sprintf("%s__%d__%d", owner.String(), tickLower, tickUpper)

	encoded := base64.StdEncoding.EncodeToString([]byte(key))
	return encoded
}

func handleLeftoverNativeToken(token0IsNative, token1IsNative bool, userWugnotBalance uint64, caller std.Address) {
	if !hasNativeToken(token0IsNative, token1IsNative) {
		return
	}

	userWugnotAfterMint := wugnot.BalanceOf(a2u(caller))

	leftOver := userWugnotAfterMint - userWugnotBalance
	if leftOver > 0 {
		unwrap(leftOver, caller)
	}
}


func hasWugnotToken(isToken0Wugnot, isToken1Wugnot bool) bool {
	return isToken0Wugnot || isToken1Wugnot
}

func SetPositionOperator(tokenId uint64, operator std.Address) {
	caller := std.PrevRealm().PkgPath()
	if caller != consts.STAKER_PATH {
		panic(addDetailToError(
			errNoPermission,
			ufmt.Sprintf("caller(%s) is not staker", caller),
		))
	}

	position, exist := positions[tokenId]
	if !exist {
		panic(addDetailToError(
			errDataNotFound,
			ufmt.Sprintf("position(%d) doesn't exist", tokenId),
		))
	}

	position.operator = operator
	positions[tokenId] = position
}