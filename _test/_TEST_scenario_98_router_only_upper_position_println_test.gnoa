// SwapRoute & DrySwapRoute [ 2 position 1 route 1 hop ]
package swap_scenario

import (
	"std"
	"testing"

	"gno.land/p/demo/testutils"

	"gno.land/r/demo/consts"

	pl "gno.land/r/demo/pool"
	pn "gno.land/r/demo/position"
	rr "gno.land/r/demo/router"

	"gno.land/r/demo/bar"
	"gno.land/r/demo/baz"

	"gno.land/r/demo/gns"
)

var (
	lp01 = testutils.TestAddress("lp01")
	tr01 = testutils.TestAddress("tr01")
)

func TestPoolInitByAdmin(t *testing.T) {
	std.TestSetOrigCaller(gsa)
	pl.InitManual()

	std.TestSkipHeights(1)
}

func TestPoolCreatePools(t *testing.T) {
	std.TestSetPrevAddr(test1)
	gns.Approve(a2u(consts.POOL_ADDR), consts.POOL_CREATION_FEE)

	// bar-baz
	pl.CreatePool(barPath, bazPath, 100, "354340008410679467268648495215") // tick 29960 ≈ 1:20

	std.TestSkipHeights(4)
}

func TestFaucetLP01(t *testing.T) {
	std.TestSetOrigCaller(lp01)

	shouldEQ(t, bar.BalanceOf(a2u(lp01)), 0)
	shouldEQ(t, baz.BalanceOf(a2u(lp01)), 0)

	bar.Faucet(lp01)
	baz.Faucet(lp01)

	shouldEQ(t, bar.BalanceOf(a2u(lp01)), 100000000)
	shouldEQ(t, baz.BalanceOf(a2u(lp01)), 100000000)

	std.TestSkipHeights(5)
}

// func TestPositionMintBarBazInRange(t *testing.T) {
// 	std.TestSetOrigCaller(lp01)

// 	// approve bar, baz to pool ( position.Mint() calls pool.Mint() ≈ so approve to pool )
// 	bar.Approve(a2u(consts.POOL_ADDR), 10000000)
// 	baz.Approve(a2u(consts.POOL_ADDR), 10000000)

// 	tokenId, liquidity, amount0, amoutn1 := pn.Mint(
// 		barPath,     // token0
// 		bazPath,     // token1
// 		100,         // fee
// 		29940,       // tickLower
// 		29980,       // tickUpper
// 		"1000",        // amount0Desired
// 		"1000",        // amount1Desired
// 		"0",           // amount0Min
// 		"0",           // amount1Min
// 		max_timeout, // deadline
// 	)
// 	// shouldEQ(t, tokenId, 1)
// 	shouldEQ(t, liquidity, "223717"))
// 	shouldEQ(t, amount0, "49"))
// 	shouldEQ(t, amoutn1, "1000"))

// 	poolBar := bar.BalanceOf(a2u(consts.POOL_ADDR))
// 	poolBaz := baz.BalanceOf(a2u(consts.POOL_ADDR))
// 	println("Pool Token0(BAR) Balance:", poolBar)
// 	println("Pool Token1(BAZ) Balance:", poolBaz)

// 	std.TestSkipHeights(3)
// }

func TestPositionMintBarBazUpperRange(t *testing.T) {
	std.TestSetOrigCaller(lp01)

	// approve bar, baz to pool ( position.Mint() calls pool.Mint() ≈ so approve to pool )
	bar.Approve(a2u(consts.POOL_ADDR), 10000000)
	baz.Approve(a2u(consts.POOL_ADDR), 10000000)

	tokenId, liquidity, amount0, amoutn1 := pn.Mint(
		barPath,     // token0
		bazPath,     // token1
		100,         // fee
		30000,       // tickLower
		34000,       // tickUpper
		"1000",      // amount0Desired
		"1000",      // amount1Desired
		"0",         // amount0Min
		"0",         // amount1Min
		max_timeout, // deadline
	)
	// shouldEQ(t, tokenId, "2")
	shouldEQ(t, liquidity, "24723")
	shouldEQ(t, amount0, "1000")
	shouldEQ(t, amoutn1, "0")

	poolBar := bar.BalanceOf(a2u(consts.POOL_ADDR))
	poolBaz := baz.BalanceOf(a2u(consts.POOL_ADDR))
	std.TestSkipHeights(3)
}

func TestFaucetTR01(t *testing.T) {
	std.TestSetOrigCaller(tr01)

	shouldEQ(t, bar.BalanceOf(a2u(tr01)), 0)
	shouldEQ(t, baz.BalanceOf(a2u(tr01)), 0)

	bar.Faucet(tr01)
	baz.Faucet(tr01)

	shouldEQ(t, bar.BalanceOf(a2u(tr01)), 100000000)
	shouldEQ(t, baz.BalanceOf(a2u(tr01)), 100000000)

	std.TestSkipHeights(5)
}

func TestRouterDrySwapRouteBazBarExactIn(t *testing.T) {
	std.TestSetOrigCaller(tr01)

	dryResult := rr.DrySwapRoute(
		bazPath,    // inputToken
		barPath,    // outputToken
		"1000",     // amountSpecified
		"EXACT_IN", // swapType
		"gno.land/r/demo/baz:gno.land/r/demo/bar:100", // strRouteArr
		"100", // quoteArr
	)
	// BAR:BAZ ≈ 1:20
	// BAZ:BAR = 1:0.05
	println("EXACT_IN_dryResult:", dryResult)
	std.TestSkipHeights(2)
}

func TestRouterSwapRouteBazBarExactIn(t *testing.T) {
	std.TestSetOrigCaller(tr01)

	// approve bar to pool
	baz.Approve(a2u(consts.POOL_ADDR), 100000)

	oldBar := bar.BalanceOf(a2u(tr01))
	oldBaz := baz.BalanceOf(a2u(tr01))

	swapResult := rr.SwapRoute(
		bazPath,    // inputToken
		barPath,    // outputToken
		"1000",     // amountSpecified
		"EXACT_IN", // swapType
		"gno.land/r/demo/baz:gno.land/r/demo/bar:100", // strRouteArr
		"100", // quoteArr
		"48",  // tokenAmountLimit (minReceived)
	)
	println("EXACT_IN_swapResult:", swapResult)

	newBar := bar.BalanceOf(a2u(tr01))
	newBaz := baz.BalanceOf(a2u(tr01))

	println("sentBaz:", oldBaz-newBaz)
	println("R recvBar:", newBar-oldBar)

	std.TestSkipHeights(2)
}

func TestRouterDrySwapRouteBazBarExactInTooMuch(t *testing.T) {
	std.TestSetOrigCaller(tr01)

	dryResult := rr.DrySwapRoute(
		bazPath,     // inputToken
		barPath,     // outputToken
		"100000000", // amountSpecified
		"EXACT_IN",  // swapType
		"gno.land/r/demo/baz:gno.land/r/demo/bar:100", // strRouteArr
		"100", // quoteArr
	)
	println("EXACT_IN_dryResult:", dryResult) // dry needs to be fail(return -1), due to not enough balance
	std.TestSkipHeights(2)
}

func TestRouterSwapRouteBazBarExactInTooMuch(t *testing.T) {
	std.TestSetOrigCaller(tr01)

	// approve bar to pool
	baz.Approve(a2u(consts.POOL_ADDR), 100000)
	bar.Approve(a2u(consts.ROUTER_ADDR), uint64(100000000))

	oldBar := bar.BalanceOf(a2u(tr01))
	oldBaz := baz.BalanceOf(a2u(tr01))

	shouldPanicWithMsg(t, func() {
		rr.SwapRoute(
			bazPath,     // inputToken
			barPath,     // outputToken
			"100000000", // amountSpecified
			"EXACT_IN",  // swapType
			"gno.land/r/demo/baz:gno.land/r/demo/bar:100", // strRouteArr
			"100",      // quoteArr
			"10000000", // tokenAmountLimit (minReceived)
		)
	},
		"[ROUTER] router.gno__SwapRoute() || too few received (expected minimum output:10000000, actual output:946)",
	)
}
