package governance

import (
	"std"
	"strings"
	"testing"
	"time"

	"gno.land/r/gnoswap/v2/consts"
	"gno.land/r/gnoswap/v2/gns"
	gs "gno.land/r/gnoswap/v2/gov/staker"

	u256 "gno.land/p/gnoswap/uint256"

	"gno.land/p/demo/ufmt"
)

func TestProposeTextType(t *testing.T) {
	t.Run("Proposal with insufficient stake", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if !strings.HasPrefix(string(r), "THRESHOLD NOT MET") {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()

		proposalId := Propose("TEXT", "p_title", "p_text", "")
	})

	t.Run("Successful proposal text", func(t *testing.T) {
		std.TestSetOrigCaller(gsa)
		std.TestSetRealm(gsaRealm)
		gns.Approve(a2u(consts.GOV_STAKER_ADDR), uint64(1_000_000))
		gs.Delegate(gsa, uint64(1_000_000))
		std.TestSkipHeights(1)

		proposalId := Propose("TEXT", "p_title", "p_text", "")
		if proposalId != 2 {
			t.Errorf("Expected proposal ID to be 2, got %d", proposalId)
		}

		proposal, exist := proposals[proposalId]
		if !exist {
			t.Errorf("Proposal not found after creation")
		}

		if proposal.Proposer != std.GetOrigCaller() {
			t.Errorf("Incorrect proposer. Expected %v, got %v", std.GetOrigCaller(), proposal.Proposer)
		}

		if !proposal.ExecutionState.Created {
			t.Errorf("Proposal execute state not set correctly")
		}

		if proposal.Yea.Cmp(u256.NewUint(0)) != 0 || proposal.Nay.Cmp(u256.NewUint(0)) != 0 {
			t.Errorf("Initial vote counts should be zero")
		}
	})

	t.Run("Proposal with active proposal", func(t *testing.T) {
		std.TestSetOrigCaller(gsa)
		std.TestSetRealm(gsaRealm)

		// Try to create another proposal immediately
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if r != "PROPOSER_HAS_ACTIVE_PROPOSAL" {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()
		Propose("TEXT", "p_title", "p_text", "")
	})
}

func TestVote(t *testing.T) {
	proposalId := uint64(2)
	proposal, exist := proposals[proposalId]
	if !exist {
		t.Fatalf("Proposal #2 not found")
	}

	std.TestSetOrigCaller(gsa)
	std.TestSetRealm(gsaRealm)

	t.Run("Vote before voting period", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if r != ufmt.Sprintf("voting has not started yet. Current time: %d, Voting start time: %d", time.Now().Unix(), proposal.ExecutionState.CreatedAt+config.VotingStartDelay) {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()

		Vote(proposalId, true)
	})

	t.Run("Successful vote", func(t *testing.T) {
		// Set the current time to be within the voting period
		std.TestSkipHeights(51)

		voteKey := Vote(proposalId, true)

		proposal := proposals[proposalId]
		if proposal.Yea.Cmp(u256.NewUint(1000000)) != 0 {
			t.Errorf("Expected Yea votes to be 1000000, got %s", proposal.Yea.ToString())
		}

		vote, exist := votes[voteKey]
		if !exist {
			t.Errorf("Vote not recorded")
		}
		if !vote {
			t.Errorf("Expected vote to be true, got %t", vote)
		}
	})

	t.Run("Vote twice", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if !strings.Contains(string(r), "has already voted") {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()
		Vote(proposalId, true)
	})

	t.Run("Vote after voting period", func(t *testing.T) {
		std.TestSkipHeights(100000)
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if !strings.Contains(string(r), "has ended") {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()
		Vote(proposalId, true)
	})
}

func TestCancel(t *testing.T) {
	proposalId := Propose("TEXT", "p_title", "p_text", "")
	if proposalId != 4 {
		t.Errorf("Expected proposal ID to be 4, got %d", proposalId)
	}

	if len(proposals) != 2 {
		t.Errorf("Expected 2 proposals, got %d", len(proposals))
	}

	t.Run("Successful cancel by proposer", func(t *testing.T) {
		Cancel(proposalId)

		proposal := proposals[proposalId]
		if !proposal.ExecutionState.Canceled {
			t.Errorf("Proposal was not canceled")
		}
	})

	t.Run("Cancel already canceled proposal", func(t *testing.T) {
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if r != ufmt.Sprintf("proposal %d has already been canceled", proposalId) {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()

		Cancel(proposalId)
	})

	t.Run("Cancel after voting started", func(t *testing.T) {
		proposalId := Propose("TEXT", "p_title", "p_text", "")
		if proposalId != 5 {
			t.Errorf("Expected proposal ID to be 5, got %d", proposalId)
		}

		if len(proposals) != 3 {
			t.Errorf("Expected 3 proposals, got %d", len(proposals))
		}

		// Set the current time to be after voting start
		defer func() {
			if r := recover(); r == nil {
				t.Errorf("The code did not panic")
			} else if r != ufmt.Sprintf("voting has already started for proposal %d", proposalId) {
				t.Errorf("Unexpected panic: %v", r)
			}
		}()

		std.TestSkipHeights(51)
		Cancel(proposalId)
	})
}

// ==== XXX: Dynamic Call ====
// func TestExecuteCall(t *testing.T) {
// 	tests := []struct {
// 		name     string
// 		selector uint64
// 		calldata string
// 		register func(uint64)
// 		expected string
// 		wantErr  bool
// 	}{
// 		{
// 			name:     "Simple concatenation",
// 			selector: 1,
// 			calldata: "World",
// 			register: func(selector uint64) {
// 				RegisterFunction(selector, func(args ...string) (string, error) {
// 					if len(args) < 1 {
// 						return "", errors.New("no data provided")
// 					}
// 					return "Hello, " + strings.Join(args, " "), nil
// 				})
// 			},
// 			expected: "Hello, World",
// 			wantErr:  false,
// 		},
// 		{
// 			name:     "Uppercase conversion",
// 			selector: 2,
// 			calldata: "lowercase",
// 			register: func(selector uint64) {
// 				RegisterFunction(selector, func(data ...string) (string, error) {
// 					if len(data) < 1 {
// 						return "", errors.New("no data provided")
// 					}
// 					return strings.ToUpper(data[0]), nil
// 				})
// 			},
// 			expected: "LOWERCASE",
// 			wantErr:  false,
// 		},
// 		{
// 			name:     "Error case",
// 			selector: 3,
// 			calldata: "error",
// 			register: func(selector uint64) {
// 				RegisterFunction(selector, func(data ...string) (string, error) {
// 					return "", errors.New("test error")
// 				})
// 			},
// 			expected: "",
// 			wantErr:  true,
// 		},
// 		{
// 			name:     "multiple arguments",
// 			selector: 4,
// 			calldata: "arg1,arg2,arg3",
// 			register: func(selector uint64) {
// 				RegisterFunction(selector, func(data ...string) (string, error) {
// 					if len(data) < 3 {
// 						return "", errors.New("not enough arguments")
// 					}
// 					return strings.Join(data, " "), nil
// 				})
// 			},
// 			expected: "arg1 arg2 arg3",
// 			wantErr:  false,
// 		},
// 		{
// 			name:     "Unregistered function",
// 			selector: 4,
// 			calldata: "test",
// 			register: func(selector uint64) {
// 				// Don't register any function
// 			},
// 			expected: "",
// 			wantErr:  true,
// 		},
// 	}

// 	for _, tt := range tests {
// 		t.Run(tt.name, func(t *testing.T) {
// 			tt.register(tt.selector)

// 			call := Call{
// 				To:       testutils.TestAddress("test_address"),
// 				Selector: tt.selector,
// 				Calldata: tt.calldata,
// 			}

// 			if tt.wantErr {
// 				defer func() {
// 					if r := recover(); r == nil {
// 						t.Errorf("executeCall() did not panic as expected")
// 					}
// 				}()
// 			}

// 			result := executeCall(call)

// 			if !tt.wantErr {
// 				if result != tt.expected {
// 					t.Errorf("executeCall() = %s, want %s", result, tt.expected)
// 				}
// 			}
// 		})
// 	}
// }

// func TestExecute(t *testing.T) {
// 	RegisterFunction(1, func(args ...string) (string, error) {
// 		if len(args) < 1 {
// 			return "", errors.New("no data provided")
// 		}
// 		return "Executed: " + strings.Join(args, " "), nil
// 	})

// 	setupGovernor := func() (string, string, Config) {
// 		mockStaker := &MockStaker{
// 			averageDelegated: u256.NewUint(1000),
// 		}

// 		config := Config{
// 			VotingStartDelay:              100,
// 			VotingPeriod:                  1000,
// 			VotingWeightSmoothingDuration: 100,
// 			Quorum:                        500,
// 			ProposalCreationThreshold:     100,
// 			ExecutionDelay:                100,
// 			ExecutionWindow:               1000,
// 		}

// 		Init(mockStaker, config)

// 		callsJSON := ufmt.Sprintf(
// 			`[{"to":"%s","selector":1,"calldata":"test_data"}]`,
// 			testutils.TestAddress("test_address").String(),
// 		)

// 		id, _ := Propose(callsJSON)

// 		// Set the time to be after voting has started
// 		proposalValue, _ := gGovernor.proposals.Get(id)
// 		proposal := proposalValue.(ProposalInfo)

// 		votingStartTime := proposal.ExecutionState.Created + config.VotingStartDelay + 1
// 		origTimeNow := timeNow
// 		timeNow = func() time.Time { return time.Unix(int64(votingStartTime), 0) }

// 		// Set up a successful vote
// 		Vote(id, true)

// 		// Reset the time function
// 		timeNow = origTimeNow

// 		return id, callsJSON, config
// 	}

// 	t.Run("Successful execution", func(t *testing.T) {
// 		id, callsJSON, config := setupGovernor()

// 		// Set the current time to be within the execution window
// 		proposalValue, _ := gGovernor.proposals.Get(id)
// 		proposal := proposalValue.(ProposalInfo)

// 		currentTime := proposal.ExecutionState.Created + config.VotingStartDelay + config.VotingPeriod + config.ExecutionDelay + 1
// 		origTimeNow := timeNow
// 		timeNow = func() time.Time { return time.Unix(int64(currentTime), 0) }
// 		defer func() { timeNow = origTimeNow }()

// 		results := Execute(id, callsJSON)

// 		if len(results) == 0 {
// 			t.Errorf("No results returned")
// 		}

// 		rr := strings.Split(results, ",")
// 		if len(rr) != 1 {
// 			t.Errorf("Expected 1 result, got %d", len(rr))
// 		}

// 		executedProposalValue, _ := gGovernor.proposals.Get(id)
// 		executedProposal := executedProposalValue.(ProposalInfo)
// 		if executedProposal.ExecutionState.Executed == 0 {
// 			t.Errorf("Proposal was not marked as executed")
// 		}

// 		// Check the result of the executed function
// 		expectedResult := "Executed: test_data"
// 		if results != expectedResult {
// 			t.Errorf("Expected result %s, got %s", expectedResult, results[0])
// 		}
// 	})

// 	t.Run("Execution before voting ends", func(t *testing.T) {
// 		id, calls, config := setupGovernor()

// 		// Set the current time to be before voting ends
// 		proposalValue, _ := gGovernor.proposals.Get(id)
// 		proposal := proposalValue.(ProposalInfo)

// 		currentTime := proposal.ExecutionState.Created + config.VotingStartDelay + config.VotingPeriod - 1
// 		origTimeNow := timeNow
// 		timeNow = func() time.Time { return time.Unix(int64(currentTime), 0) }
// 		defer func() { timeNow = origTimeNow }()

// 		defer func() {
// 			if r := recover(); r == nil {
// 				t.Errorf("The code did not panic")
// 			} else if r != "VOTING_NOT_ENDED" {
// 				t.Errorf("Unexpected panic: %v", r)
// 			}
// 		}()

// 		Execute(id, calls)
// 	})
// }
