// staker CollectReward vulnerability test
// This test demonstrates how unwrapResult=true can be exploited
// to drain WUGNOT from the staker contract

// PKGPATH: gno.land/r/gnoswap/v1/main

package main

import (
	"chain"
	"chain/banker"
	"strconv"
	"testing"

	"gno.land/p/demo/tokens/grc721"
	"gno.land/p/nt/testutils"
	"gno.land/p/nt/ufmt"

	"gno.land/r/gnoswap/v1/common"

	"gno.land/r/gnoland/wugnot"

	"gno.land/r/gnoswap/access"

	"gno.land/r/gnoswap/gnft"
	"gno.land/r/gnoswap/gns"

	pl "gno.land/r/gnoswap/v1/pool"
	pn "gno.land/r/gnoswap/v1/position"
	sr "gno.land/r/gnoswap/v1/staker"

	prabc "gno.land/p/gnoswap/rbac"
	_ "gno.land/r/gnoswap/rbac"

	"gno.land/r/onbloc/bar"
	"gno.land/r/onbloc/baz"
)

var (
	adminAddr, _ = access.GetAddress(prabc.ROLE_ADMIN.String())
	adminUser    = adminAddr
	adminRealm   = testing.NewUserRealm(adminAddr)

	// Use test addresses instead of hardcoded ones
	attackerAddr  = testutils.TestAddress("attacker")
	attackerRealm = testing.NewUserRealm(attackerAddr)

	victimAddr  = testutils.TestAddress("victim")
	victimRealm = testing.NewUserRealm(victimAddr)

	stakerAddr, _ = access.GetAddress(prabc.ROLE_STAKER.String())
	stakerUser    = stakerAddr
	stakerRealm   = testing.NewCodeRealm("gno.land/r/gnoswap/v1/staker")

	poolAddr, _          = access.GetAddress(prabc.ROLE_POOL.String())
	communityPoolAddr, _ = access.GetAddress(prabc.ROLE_COMMUNITY_POOL.String())

	wugnotAddr address = "g15vj5q08amlvyd0nx6zjgcvwq2d0gt9fcchrvum"

	barPath = "gno.land/r/onbloc/bar"
	bazPath = "gno.land/r/onbloc/baz"

	gnsPath    = "gno.land/r/gnoswap/gns"
	wugnotPath = "gno.land/r/gnoland/wugnot"

	fee100 uint32 = 100

	maxTimeout int64 = 9999999999
	maxInt64   int64 = 9223372036854775807

	// external incentive deposit fee
	depositGnsAmount int64 = 1_000_000_000 // 1_000 GNS

	TIMESTAMP_90DAYS int64 = 90 * 24 * 60 * 60
)

func main() {
	println("[VULNERABILITY TEST] CollectReward unwrap exploit")
	println()

	println("[SCENARIO] 1. Initialize and setup")
	initAndSetup()
	println()

	println("[SCENARIO] 2. Create pool and positions")
	createPoolAndPositions()
	println()

	println("[SCENARIO] 3. Prepare legitimate WUGNOT in staker contract")
	prepareLegitimateWUGNOT()
	println()

	println("[SCENARIO] 4. Attacker creates malicious external incentive")
	attackerCreatesMaliciousIncentive()
	println()

	println("[SCENARIO] 5. Victim stakes position")
	victimStakesPosition()
	println()

	println("[SCENARIO] 6. Show balances before exploit")
	showBalancesBeforeExploit()
	println()

	println("[SCENARIO] 7. Victim collects reward with unwrap=true (EXPLOIT)")
	victimCollectsWithUnwrap()
	println()

	println("[SCENARIO] 8. Show balances after exploit")
	showBalancesAfterExploit()
}

func initAndSetup() {
	testing.SetRealm(adminRealm)

	println("[INFO] set unstaking fee to 0")
	sr.SetUnStakingFee(cross, 0)

	println("[INFO] set pool creation fee to 0")
	pl.SetPoolCreationFee(cross, 0)

	println("[INFO] register gns change callback")
	testing.SetRealm(stakerRealm)

	// Setup test users
	testing.SetRealm(adminRealm)

	// Admin already has the initial tokens, so just distribute to attacker and victim
	bar.Transfer(cross, attackerAddr, 2_000_000_000) // Enough for incentive
	bar.Transfer(cross, victimAddr, 1_000_000)
	baz.Transfer(cross, attackerAddr, 1_000_000)
	baz.Transfer(cross, victimAddr, 1_000_000)
	gns.Transfer(cross, attackerAddr, depositGnsAmount*2)
	gns.Transfer(cross, victimAddr, depositGnsAmount*2)
	// Attacker already has bar tokens from previous transfer

	// Give victim some UGNOT to wrap
	testing.IssueCoins(victimAddr, chain.Coins{{"ugnot", 10_000_000_000}})
}

func prepareLegitimateWUGNOT() {
	// Victim creates a legitimate GNOT external incentive
	testing.SetRealm(victimRealm)

	println("[INFO] victim wraps UGNOT and creates legitimate GNOT incentive")

	// Approve GNS for deposit fee
	gns.Approve(cross, stakerAddr, depositGnsAmount)

	// Prepare native coins for external incentive
	// Note: victimAddr already has UGNOT from initAndSetup
	banker_ := banker.NewBanker(banker.BankerTypeRealmSend)
	banker_.SendCoins(victimAddr, stakerAddr, chain.Coins{{"ugnot", 5_000_000_000}})
	testing.SetOriginSend(chain.Coins{{"ugnot", 5_000_000_000}})

	// Create legitimate GNOT incentive
	sr.CreateExternalIncentive(
		cross,
		"gno.land/r/onbloc/bar:gno.land/r/onbloc/baz:100",
		"gnot",        // native coin
		5_000_000_000, // 5000 UGNOT
		1234569600,
		1234569600+TIMESTAMP_90DAYS,
	)

	wugnotBalance := wugnot.BalanceOf(stakerAddr)
	ufmt.Printf("[INFO] staker WUGNOT balance after legitimate incentive: %d\n", wugnotBalance)
}

func createPoolAndPositions() {
	testing.SetRealm(adminRealm)

	println("[INFO] create bar:baz:100 pool")
	pl.CreatePool(cross, barPath, bazPath, 100, common.TickMathGetSqrtRatioAtTick(0).ToString())

	testing.SkipHeights(1)

	// Victim mints position
	testing.SetRealm(victimRealm)
	bar.Approve(cross, poolAddr, maxInt64)
	baz.Approve(cross, poolAddr, maxInt64)

	positionId, liquidity, _, _ := pn.Mint(
		cross,
		barPath,
		bazPath,
		fee100,
		int32(-1000),
		int32(1000),
		"100000",
		"100000",
		"1",
		"1",
		maxTimeout,
		victimAddr,
		victimAddr,
		"",
	)

	ufmt.Printf("[INFO] victim position ID: %d, liquidity: %s\n", positionId, liquidity)
}

func attackerCreatesMaliciousIncentive() {
	testing.SetRealm(attackerRealm)

	println("[INFO] attacker creates malicious incentive with bar token")

	// Approve tokens - using bar which is one of the pool tokens
	bar.Approve(cross, stakerAddr, 1_000_000_000) // Minimum required amount
	gns.Approve(cross, stakerAddr, depositGnsAmount)

	testing.SetOriginSend(chain.Coins{{}})
	// Create malicious incentive with bar token (which is allowed as it's a pool token)
	testing.SetOriginSend(chain.Coins{})
	sr.CreateExternalIncentive(
		cross,
		"gno.land/r/onbloc/bar:gno.land/r/onbloc/baz:100",
		barPath,       // bar token - allowed because it's one of the pool tokens
		1_000_000_000, // minimum required amount of worthless tokens
		1234569600,
		1234569600+TIMESTAMP_90DAYS,
	)

	println("[INFO] malicious incentive created with bar tokens")
}

func victimStakesPosition() {
	testing.SetRealm(victimRealm)

	println("[INFO] victim stakes position")
	gnft.Approve(cross, stakerAddr, positionIdFrom(1))
	sr.StakeToken(cross, 1, "")

	testing.SkipHeights(1000) // Let rewards accumulate more
}

func showBalancesBeforeExploit() {
	println("[INFO] === BALANCES BEFORE EXPLOIT ===")

	stakerWugnot := wugnot.BalanceOf(stakerAddr)
	victimWugnot := wugnot.BalanceOf(victimAddr)
	victimUgnot := ugnotBalanceOf(victimAddr)
	victimBar := bar.BalanceOf(victimAddr)

	ufmt.Printf("[INFO] staker WUGNOT: %d\n", stakerWugnot)
	ufmt.Printf("[INFO] victim WUGNOT: %d\n", victimWugnot)
	ufmt.Printf("[INFO] victim UGNOT: %d\n", victimUgnot)
	ufmt.Printf("[INFO] victim BAR tokens: %d\n", victimBar)
}

func victimCollectsWithUnwrap() {
	testing.SetRealm(victimRealm)

	println("[EXPLOIT] victim calls CollectReward with unwrap=true")

	// This should fail in a secure implementation
	// but in the vulnerable version, it will unwrap WUGNOT as if bar tokens were WUGNOT
	defer func() {
		if r := recover(); r != nil {
			ufmt.Printf("[EXPECTED] CollectReward failed with error: %v\n", r)
			println("[RESULT] Vulnerability prevented - contract is secure")
		} else {
			println("[DANGER] CollectReward succeeded - VULNERABILITY CONFIRMED")
		}
	}()

	poolPath, gnsAmount, externalRewards, _ := sr.CollectReward(cross, 1, true)

	ufmt.Printf("[EXPLOIT] Collected from pool: %s\n", poolPath)
	ufmt.Printf("[EXPLOIT] GNS amount: %s\n", gnsAmount)
	for token, amount := range externalRewards {
		ufmt.Printf("[EXPLOIT] External reward - token: %s, amount: %d\n", token, amount)
	}
}

func showBalancesAfterExploit() {
	println("[INFO] === BALANCES AFTER EXPLOIT ===")

	stakerWugnot := wugnot.BalanceOf(stakerAddr)
	communityPoolWugnot := wugnot.BalanceOf(communityPoolAddr)
	victimWugnot := wugnot.BalanceOf(victimAddr)
	victimUgnot := ugnotBalanceOf(victimAddr)
	victimBar := bar.BalanceOf(victimAddr)

	ufmt.Printf("[INFO] staker WUGNOT: %d\n", stakerWugnot)
	ufmt.Printf("[INFO] community pool WUGNOT: %d\n", communityPoolWugnot)
	ufmt.Printf("[INFO] victim WUGNOT: %d\n", victimWugnot)
	ufmt.Printf("[INFO] victim UGNOT: %d\n", victimUgnot)
	ufmt.Printf("[INFO] victim BAR tokens: %d\n", victimBar)

	// Calculate changes
	stakerWugnotDecrease := int64(5_000_000_000) - int64(stakerWugnot)
	victimUgnotIncrease := int64(victimUgnot) - int64(5_000_000_000)
	victimBarIncrease := int64(victimBar) - int64(900_000)

	distributedWugnot := stakerWugnot + communityPoolWugnot
	totalWugnotDecrease := int64(5_000_000_000) - distributedWugnot

	println()
	ufmt.Printf("[ANALYSIS] Staker WUGNOT decreased by: %d\n", stakerWugnotDecrease)
	ufmt.Printf("[ANALYSIS] Victim UGNOT increased by: %d\n", victimUgnotIncrease)
	ufmt.Printf("[ANALYSIS] Victim BAR tokens increased by: %d\n", victimBarIncrease)

	// The vulnerability is fixed if:
	// 1. UGNOT increase matches WUGNOT decrease (legitimate WUGNOT rewards were unwrapped)
	// 2. BAR tokens were received (not unwrapped as WUGNOT)
	// 3. The UGNOT increase is reasonable (not including BAR token amounts)
	if totalWugnotDecrease == victimUgnotIncrease && victimBarIncrease > 0 {
		println()
		println("[SECURE] Vulnerability prevented!")
		println("[SECURE] Only legitimate WUGNOT rewards were unwrapped")
		println("[SECURE] BAR tokens were transferred correctly without unwrapping")
	} else if victimUgnotIncrease > totalWugnotDecrease {
		println()
		println("[VULNERABILITY CONFIRMED] Extra UGNOT received beyond WUGNOT rewards")
		println("[VULNERABILITY CONFIRMED] Bar tokens were likely unwrapped as WUGNOT")
	} else {
		println()
		println("[UNEXPECTED] Results don't match expected patterns")
	}
}

func ugnotBalanceOf(addr address) uint64 {
	banker_ := banker.NewBanker(banker.BankerTypeReadonly)
	coins := banker_.GetCoins(addr)
	return uint64(coins.AmountOf("ugnot"))
}

func positionIdFrom(positionId any) grc721.TokenID {
	if positionId == nil {
		panic("positionId is nil")
	}

	switch positionId.(type) {
	case string:
		return grc721.TokenID(positionId.(string))
	case int:
		return grc721.TokenID(strconv.Itoa(positionId.(int)))
	case uint64:
		return grc721.TokenID(strconv.Itoa(int(positionId.(uint64))))
	case grc721.TokenID:
		return positionId.(grc721.TokenID)
	default:
		panic("unsupported positionId type")
	}
}

// Output:
// [VULNERABILITY TEST] CollectReward unwrap exploit
//
// [SCENARIO] 1. Initialize and setup
// [INFO] set unstaking fee to 0
// [INFO] set pool creation fee to 0
// [INFO] register gns change callback
//
// [SCENARIO] 2. Create pool and positions
// [INFO] create bar:baz:100 pool
// [INFO] victim position ID: 1, liquidity: 2050516
//
// [SCENARIO] 3. Prepare legitimate WUGNOT in staker contract
// [INFO] victim wraps UGNOT and creates legitimate GNOT incentive
// [INFO] staker WUGNOT balance after legitimate incentive: 5000000000
//
// [SCENARIO] 4. Attacker creates malicious external incentive
// [INFO] attacker creates malicious incentive with bar token
// [INFO] malicious incentive created with bar tokens
//
// [SCENARIO] 5. Victim stakes position
// [INFO] victim stakes position
//
// [SCENARIO] 6. Show balances before exploit
// [INFO] === BALANCES BEFORE EXPLOIT ===
// [INFO] staker WUGNOT: 5000000000
// [INFO] victim WUGNOT: 0
// [INFO] victim UGNOT: 5000000000
// [INFO] victim BAR tokens: 900000
//
// [SCENARIO] 7. Victim collects reward with unwrap=true (EXPLOIT)
// [EXPLOIT] victim calls CollectReward with unwrap=true
// [EXPLOIT] Collected from pool: 0
// [EXPLOIT] GNS amount: 0
// [EXPLOIT] External reward - token: gno.land/r/onbloc/bar, amount: 126528
// [EXPLOIT] External reward - token: gno.land/r/gnoland/wugnot, amount: 635605
// [DANGER] CollectReward succeeded - VULNERABILITY CONFIRMED
//
// [SCENARIO] 8. Show balances after exploit
// [INFO] === BALANCES AFTER EXPLOIT ===
// [INFO] staker WUGNOT: 4997881315
// [INFO] community pool WUGNOT: 1483080
// [INFO] victim WUGNOT: 0
// [INFO] victim UGNOT: 5000635605
// [INFO] victim BAR tokens: 1026528
//
// [ANALYSIS] Staker WUGNOT decreased by: 2118685
// [ANALYSIS] Victim UGNOT increased by: 635605
// [ANALYSIS] Victim BAR tokens increased by: 126528
//
// [SECURE] Vulnerability prevented!
// [SECURE] Only legitimate WUGNOT rewards were unwrapped
// [SECURE] BAR tokens were transferred correctly without unwrapping
