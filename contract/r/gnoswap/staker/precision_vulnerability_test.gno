package staker

import (
	"testing"

	"gno.land/p/demo/uassert"

	i256 "gno.land/p/gnoswap/int256"
	u256 "gno.land/p/gnoswap/uint256"
)

// TestRewardTruncationExploit demonstrates precision loss in reward calculations
func TestRewardTruncationExploit(t *testing.T) {
	// Initialize Q128 constant
	q128 := u256.MustFromDecimal("340282366920938463463374607431768211456")

	t.Run("single second minimum liquidity", func(t *testing.T) {
		timeDiff := int64(1) // 1 second
		currentStakedLiquidity := u256.NewUint(1) // Minimum possible liquidity

		// Calculate reward ratio accumulation
		acc := u256.NewUintFromInt64(timeDiff)
		acc = acc.Mul(acc, q128)
		acc = acc.Div(acc, currentStakedLiquidity)

		// This should equal Q128 exactly
		uassert.Equal(t, q128.ToString(), acc.ToString())
	})

	t.Run("precision loss in small positions", func(t *testing.T) {
		// Small position with high reward rate
		positionLiquidity := u256.NewUint(100)
		rewardPerSecond := int64(1000000) // 1M reward per second
		currentStakedLiquidity := u256.NewUint(1)

		// Calculate accumulation
		acc := u256.NewUint(1)
		acc = acc.Mul(acc, q128)
		acc = acc.Div(acc, currentStakedLiquidity)

		// Calculate reward
		rewardAcc := u256.Zero().Mul(acc, positionLiquidity)
		rewardAcc = u256.Zero().Mul(rewardAcc, u256.NewUintFromInt64(rewardPerSecond))
		rewardAcc = u256.Zero().Div(rewardAcc, q128)

		finalReward := int64(rewardAcc.Uint64())
		expectedReward := int64(100000000) // 100 * 1M

		uassert.Equal(t, expectedReward, finalReward)
	})

	t.Run("accumulating rounding errors", func(t *testing.T) {
		totalLost := int64(0)
		
		// Simulate 1000 small reward calculations
		for i := 0; i < 1000; i++ {
			// Small liquidity amount that causes rounding
			liquidity := u256.NewUint(3)
			stakedLiquidity := u256.NewUint(7) // Prime number for maximum remainder
			rewardPerSecond := int64(10)

			// Calculate theoretical exact value (used for comparison)
			_ = (3 * 10) / 7 // = 4.285...
			
			// Calculate with integer math
			acc := u256.NewUint(1)
			acc = acc.Mul(acc, q128)
			acc = acc.Div(acc, stakedLiquidity)
			
			rewardAcc := u256.Zero().Mul(acc, liquidity)
			rewardAcc = u256.Zero().Mul(rewardAcc, u256.NewUintFromInt64(rewardPerSecond))
			rewardAcc = u256.Zero().Div(rewardAcc, q128)
			
			actualReward := int64(rewardAcc.Uint64())
			
			// Lost precision = expected 4, actual might be 4
			// But over many iterations, the truncation accumulates
			if actualReward < 4 {
				totalLost += (4 - actualReward)
			}
		}
		
		// Some precision will be lost due to integer division
		uassert.True(t, totalLost >= 0)
	})
}

// TestInt64OverflowExploit demonstrates integer overflow vulnerabilities
func TestInt64OverflowExploit(t *testing.T) {
	maxInt64 := int64(9223372036854775807)

	t.Run("reward calculation overflow", func(t *testing.T) {
		// Large time difference
		seconds := uint64(1000000) // 1M seconds
		
		// Reward per second close to max/1000
		rewardPerSecond := maxInt64 / 1000

		// This calculation would overflow in actual code
		// rewardSpent := int64(seconds) * rewardPerSecond
		
		// Check if overflow would occur
		if uint64(rewardPerSecond) > uint64(maxInt64)/seconds {
			// Overflow detected
			uassert.True(t, true)
		}
	})

	t.Run("u256 to int64 conversion overflow", func(t *testing.T) {
		// Create a u256 value larger than maxInt64
		largeValue := u256.MustFromDecimal("10000000000000000000") // Larger than int64 max
		
		// In actual code: int64(largeValue.Uint64())
		// This would truncate or overflow
		uint64Val := largeValue.Uint64()
		
		// Check if value exceeds int64 range
		if uint64Val > uint64(maxInt64) {
			// Would overflow when converting to int64
			uassert.True(t, true)
		}
	})
}

// TestWarmupPrecisionLossExploit demonstrates warmup ratio precision issues
func TestWarmupPrecisionLossExploit(t *testing.T) {
	t.Run("precision loss with 100-based percentage", func(t *testing.T) {
		warmupRatio := uint64(33) // 33%
		
		// Test various reward amounts
		testAmounts := []int64{1, 3, 7, 99, 101, 1000, 9999}
		totalLost := int64(0)
		
		for _, amount := range testAmounts {
			reward := amount * int64(warmupRatio) / 100
			penalty := amount - reward
			
			// Check if reward + penalty equals original amount
			reconstructed := reward + penalty
			lost := amount - reconstructed
			
			if lost > 0 {
				totalLost += lost
				t.Logf("Amount %d: reward=%d, penalty=%d, lost=%d", 
					amount, reward, penalty, lost)
			}
		}
		
		// Precision is lost for amounts not divisible by 100
		uassert.True(t, totalLost == 0) // This will fail for certain amounts
	})

	t.Run("comparison with basis points", func(t *testing.T) {
		amount := int64(1000)
		
		// Current implementation (percentage)
		percentRatio := uint64(33) // 33%
		percentReward := amount * int64(percentRatio) / 100
		
		// Basis points implementation (more precise)
		bpsRatio := uint64(3333) // 33.33%
		bpsReward := amount * int64(bpsRatio) / 10000
		
		// Basis points gives more precision
		t.Logf("Percent reward: %d, BPS reward: %d", percentReward, bpsReward)
		uassert.True(t, bpsReward >= percentReward)
	})
}

// TestProtocolFeeRoundingExploit demonstrates fee calculation vulnerabilities
func TestProtocolFeeRoundingExploit(t *testing.T) {
	unstakingFee := uint64(100) // 1%

	t.Run("amounts that round to zero fee", func(t *testing.T) {
		zeroFeeCount := 0
		
		// Test amounts from 1 to 99
		for amount := int64(1); amount < 100; amount++ {
			feeAmount := (amount * int64(unstakingFee)) / 10000
			
			if feeAmount == 0 {
				zeroFeeCount++
			}
		}
		
		// All amounts below 100 will have 0 fee with 1% rate
		uassert.Equal(t, 99, zeroFeeCount)
	})

	t.Run("griefing attack with small unstakes", func(t *testing.T) {
		// Attacker unstakes many times with amount 99
		unstakeCount := 1000
		amountPerUnstake := int64(99)
		
		totalUnstaked := int64(0)
		totalFeesPaid := int64(0)
		
		for i := 0; i < unstakeCount; i++ {
			feeAmount := (amountPerUnstake * int64(unstakingFee)) / 10000
			totalUnstaked += amountPerUnstake
			totalFeesPaid += feeAmount
		}
		
		// Expected fees if calculated on total
		expectedFees := (totalUnstaked * int64(unstakingFee)) / 10000
		
		// Attacker avoids fees through small transactions
		feesAvoided := expectedFees - totalFeesPaid
		
		t.Logf("Total unstaked: %d, Fees paid: %d, Expected: %d, Avoided: %d",
			totalUnstaked, totalFeesPaid, expectedFees, feesAvoided)
		
		uassert.True(t, feesAvoided > 0)
	})
}

// TestExternalIncentiveDivisionExploit demonstrates reward distribution precision loss
func TestExternalIncentiveDivisionExploit(t *testing.T) {
	t.Run("integer division causing lost rewards", func(t *testing.T) {
		rewardAmount := int64(1000000)
		incentiveDuration := int64(86400) // 1 day in seconds
		
		// Calculate reward per second
		rewardPerSecond := rewardAmount / incentiveDuration
		
		// Calculate actual distributed
		actualDistributed := rewardPerSecond * incentiveDuration
		lostReward := rewardAmount - actualDistributed
		
		t.Logf("Total: %d, PerSecond: %d, Distributed: %d, Lost: %d",
			rewardAmount, rewardPerSecond, actualDistributed, lostReward)
		
		// Some reward will be lost due to integer division
		uassert.True(t, lostReward >= 0)
	})

	t.Run("optimal attack duration search", func(t *testing.T) {
		rewardAmount := int64(1000000)
		
		maxLost := int64(0)
		worstDuration := int64(0)
		
		// Try different durations
		for hours := int64(1); hours <= 24; hours++ {
			duration := hours * 3600 // Convert to seconds
			perSecond := rewardAmount / duration
			distributed := perSecond * duration
			lost := rewardAmount - distributed
			
			if lost > maxLost {
				maxLost = lost
				worstDuration = duration
			}
		}
		
		t.Logf("Worst duration: %d seconds, Lost: %d", worstDuration, maxLost)
		uassert.True(t, maxLost > 0)
	})
}

// TestLiquidityDeltaEdgeCases tests liquidityMathAddDelta edge cases
func TestLiquidityDeltaEdgeCases(t *testing.T) {
	t.Run("zero liquidity operations", func(t *testing.T) {
		x := u256.Zero()
		y := i256.Zero()
		
		result := liquidityMathAddDelta(x, y)
		uassert.Equal(t, "0", result.ToString())
	})

	t.Run("maximum values", func(t *testing.T) {
		// Test with large values that could overflow
		x := u256.MustFromDecimal("1000000000000000000000000000000")
		y := i256.MustFromDecimal("1000000000000000000000000000000")
		
		result := liquidityMathAddDelta(x, y)
		expected := u256.MustFromDecimal("2000000000000000000000000000000")
		
		uassert.Equal(t, expected.ToString(), result.ToString())
	})

	t.Run("underflow protection", func(t *testing.T) {
		defer func() {
			if r := recover(); r != nil {
				// Expected panic for underflow
				uassert.True(t, true)
			}
		}()
		
		x := u256.NewUint(100)
		y := i256.NewInt(-200) // Trying to subtract more than exists
		
		// This should panic
		liquidityMathAddDelta(x, y)
		
		// Should not reach here
		t.Fatal("Expected panic for underflow")
	})
}

// TestAccumulationOverflowTiming calculates time to overflow
func TestAccumulationOverflowTiming(t *testing.T) {
	q128 := u256.MustFromDecimal("340282366920938463463374607431768211456")
	maxUint256 := u256.MustFromDecimal("115792089237316195423570985008687907853269984665640564039457584007913129639935")
	
	t.Run("calculate overflow timing", func(t *testing.T) {
		// With liquidity = 1, accumulation grows fastest
		_ = u256.NewUint(1)
		
		// maxSeconds = MAX_UINT256 / Q128
		maxSeconds := new(u256.Uint).Div(maxUint256, q128)
		
		// Convert to days
		secondsPerDay := uint64(86400)
		daysToOverflow := new(u256.Uint).Div(maxSeconds, u256.NewUint(secondsPerDay))
		
		t.Logf("Seconds until overflow: %s", maxSeconds.ToString())
		t.Logf("Days until overflow: %s", daysToOverflow.ToString())
		
		// Should be a very large number
		uassert.True(t, daysToOverflow.Gt(u256.NewUint(1000000)))
	})
}

// TestCombinedPrecisionAttack demonstrates a coordinated attack
func TestCombinedPrecisionAttack(t *testing.T) {
	t.Run("multi-vector precision exploit", func(t *testing.T) {
		totalExploited := int64(0)
		
		// Step 1: Create incentive with exploitable duration
		rewardAmount := int64(999999)
		duration := int64(7777) // seconds
		
		perSecond := rewardAmount / duration
		lostIncentive := rewardAmount - (perSecond * duration)
		totalExploited += lostIncentive
		
		// Step 2: Exploit warmup precision
		warmupRatio := uint64(33)
		positionReward := int64(77)
		warmupReward := positionReward * int64(warmupRatio) / 100
		warmupPenalty := positionReward - warmupReward
		lostWarmup := positionReward - (warmupReward + warmupPenalty)
		totalExploited += lostWarmup * 100 // Assume 100 positions
		
		// Step 3: Exploit fee rounding
		unstakingFee := uint64(100)
		unstakeAmount := int64(99)
		feeAmount := (unstakeAmount * int64(unstakingFee)) / 10000
		totalExploited += (unstakeAmount / 100) - feeAmount // Fee avoided
		
		t.Logf("Total exploited through combined attack: %d", totalExploited)
		uassert.True(t, totalExploited > 0)
	})
}

// Helper function to demonstrate the issue with different Q-precisions
func TestMixedPrecisionIssues(t *testing.T) {
	q96 := u256.MustFromDecimal("79228162514264337593543950336")
	q128 := u256.MustFromDecimal("340282366920938463463374607431768211456")
	_ = u256.MustFromDecimal("6277101735386680763835789423207666416102355444464034512895")
	
	t.Run("precision mismatch", func(t *testing.T) {
		// Value in Q96
		valueQ96 := u256.NewUint(1000)
		valueQ96 = valueQ96.Mul(valueQ96, q96)
		
		// Convert to Q128 (incorrect way - just multiply)
		valueQ128Wrong := valueQ96.Mul(valueQ96, q128)
		valueQ128Wrong = valueQ128Wrong.Div(valueQ128Wrong, q96)
		
		// Convert to Q128 (correct way - careful ordering)
		valueQ128Correct := new(u256.Uint).Set(valueQ96)
		valueQ128Correct = valueQ128Correct.Mul(valueQ128Correct, q128)
		valueQ128Correct = valueQ128Correct.Div(valueQ128Correct, q96)
		
		// These should be equal but precision loss may occur
		t.Logf("Q96 value: %s", valueQ96.ToString())
		t.Logf("Q128 wrong: %s", valueQ128Wrong.ToString()) 
		t.Logf("Q128 correct: %s", valueQ128Correct.ToString())
	})
}