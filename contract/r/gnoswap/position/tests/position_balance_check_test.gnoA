package position

import (
	"std"
	"strconv"
	"testing"
	"time"

	"gno.land/p/demo/testutils"
	"gno.land/p/demo/uassert"
	"gno.land/p/gnoswap/consts"

	i256 "gno.land/p/gnoswap/int256"
	u256 "gno.land/p/gnoswap/uint256"
	"gno.land/r/demo/wugnot"
	"gno.land/r/gnoswap/v1/access"
	"gno.land/r/gnoswap/v1/common"
	"gno.land/r/gnoswap/v1/gns"
	pl "gno.land/r/gnoswap/v1/pool"
	rr "gno.land/r/gnoswap/v1/router"
)

func TestPositionBalanceCompareWithPoolBalance(t *testing.T) {
	aliceAddr := testutils.TestAddress("alice")
	bobAddr := testutils.TestAddress("bob")
	adminAddr, _ := access.GetAddress(access.ROLE_ADMIN)
	poolAddr, _ := access.GetAddress(access.ROLE_POOL)
	routerAddr, _ := access.GetAddress(access.ROLE_ROUTER)

	aliceRealm := std.NewUserRealm(aliceAddr)
	bobRealm := std.NewUserRealm(bobAddr)
	adminRealm := std.NewUserRealm(adminAddr)

	defaultTick := int32(1)
	token0Path := "gno.land/r/demo/wugnot"
	token1Path := "gno.land/r/gnoswap/v1/gns"
	fee := uint32(3000)

	t.Run("distribute gns token ", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000000)
		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. transfer gns
		gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
		gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
		uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(aliceAddr))
		uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(bobAddr))
	})

	t.Run("distribute wugnot token ", func(t *testing.T) {
		tokenAmountForDistribute := int64(1000000000000)
		fullTokenAmount := tokenAmountForDistribute * 1000000

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)

		// 1. transfer ugnot
		testing.SetOriginCaller(adminAddr)
		newCoins := std.Coins{{"ugnot", fullTokenAmount}}
		distributeCoins := std.Coins{{"ugnot", tokenAmountForDistribute}}
		testing.IssueCoins(adminAddr, newCoins)
		testing.SetOriginSend(newCoins)
		banker := std.NewBanker(std.BankerTypeRealmSend)
		banker.SendCoins(adminAddr, consts.WUGNOT_ADDR, distributeCoins)
		banker.SendCoins(adminAddr, aliceAddr, distributeCoins)
		banker.SendCoins(adminAddr, bobAddr, distributeCoins)
		cross(wugnot.Deposit)()
		cross(wugnot.Transfer)(aliceAddr, uint64(tokenAmountForDistribute))
		cross(wugnot.Transfer)(bobAddr, uint64(tokenAmountForDistribute))

		uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(aliceAddr))
		uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(bobAddr))
	})

	t.Run("create pool - wugnot-gns-3000", func(t *testing.T) {
		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. Approve gns
		gns.Approve(poolAddr, consts.UINT64_MAX)
		// 2. Create pool
		pl.CreatePool(token0Path, token1Path, fee, common.TickMathGetSqrtRatioAtTick(defaultTick).ToString())
		poolPath := pl.GetPoolPath(token0Path, token1Path, fee)
		pool := cross(pl.GetPoolFromPoolPath)(poolPath)
		uassert.Equal(t, poolPath, pool.PoolPath())
		uassert.Equal(t, token0Path, pool.Token0Path())
		uassert.Equal(t, token1Path, pool.Token1Path())
		uassert.Equal(t, fee, pool.Fee())
		uassert.Equal(t, "0", pool.BalanceToken0().ToString())
		uassert.Equal(t, "0", pool.BalanceToken1().ToString())
		uassert.Equal(t, int32(60), pool.TickSpacing())
		uassert.Equal(t, "11505743598341114571880798222544994", pool.MaxLiquidityPerTick().ToString())
		uassert.Equal(t, "79232123823359799118286999568", pool.Slot0SqrtPriceX96().ToString())
		uassert.Equal(t, int32(1), common.TickMathGetTickAtSqrtRatio(pool.Slot0SqrtPriceX96()))
		uassert.Equal(t, int32(1), pool.Slot0Tick())
		uassert.Equal(t, uint8(0), pool.Slot0FeeProtocol())
		uassert.Equal(t, true, pool.Slot0Unlocked())
		uassert.Equal(t, "0", pool.FeeGrowthGlobal0X128().ToString())
		uassert.Equal(t, "0", pool.FeeGrowthGlobal1X128().ToString())
		uassert.Equal(t, "0", pool.ProtocolFeesToken0().ToString())
		uassert.Equal(t, "0", pool.ProtocolFeesToken1().ToString())
		uassert.Equal(t, "0", pool.Liquidity().ToString())

		poolInfo := pl.ApiGetPool(pl.GetPoolPath(token0Path, token1Path, fee))
		uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"0","token1Balance":"0","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"0","ticks":{},"tickBitmaps":{},"positions":[]}}`,
			poolInfo)
	})

	t.Run("Distribute Gns Token", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000)
		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. transfer gns
		gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
		gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
	})

	t.Run("Mint New Position", func(t *testing.T) {
		lowerTick := int32(-6960)
		upperTick := int32(6960)
		amount0Desired := "50000000"
		amount1Desired := "50000000"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""

		// 0. Set realm to alice
		testing.SetRealm(aliceRealm)
		// 1. Approve wugnot
		cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
		// 2. Approve gns
		gns.Approve(poolAddr, consts.UINT64_MAX)
		// 3. Mint position
		beforeWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
		beforeGnsBalance := gns.BalanceOf(aliceAddr)
		id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
			token1Path,
			fee,
			lowerTick,
			upperTick,
			amount0Desired,
			amount1Desired,
			amount0Min,
			amount1Min,
			maxTimeout,
			aliceAddr,
			aliceAddr,
			referrerAddr)
		uassert.Equal(t, uint64(1), id)
		uassert.Equal(t, "49982991", amount0Str)
		uassert.Equal(t, amount1Desired, amount1Str)
		uassert.Equal(t, "170103415", liquidityStr)

		pool := pl.GetPool(token0Path, token1Path, fee)
		sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
		sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
		sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
		amount0U256 := u256.MustFromDecimal(amount0Desired)
		amount1U256 := u256.MustFromDecimal(amount1Desired)
		calculatedLiquidity := common.GetLiquidityForAmounts(
			sqrtPriceX96,
			sqrtRatioAX96,
			sqrtRatioBX96,
			amount0U256,
			amount1U256,
		)
		uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
		liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
		calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
		afterWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
		afterGnsBalance := gns.BalanceOf(aliceAddr)
		uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
		uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

		posIdOne := ApiGetPosition(id)
		uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":1,"burned":false,"owner":"g1v9kxjcm9ta047h6lta047h6lta047h6lzd40gh","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"49982991","token1Balance":"50000000","calculatedToken0Balance":"49982990","calculatedToken1Balance":"49999999","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
			posIdOne)

		poolInfo := pl.ApiGetPool(pool.PoolPath())
		uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"49982991","token1Balance":"50000000","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"170103415","ticks":{"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
			poolInfo)
	})

	t.Run("Mint New Position - 2", func(t *testing.T) {
		lowerTick := int32(-2160)
		upperTick := int32(11760)
		amount0Desired := "99999999"
		amount1Desired := "23027406"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""

		// 0. Set realm to bob
		testing.SetRealm(bobRealm)
		// 1. Approve wugnot
		cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
		// 2. Approve gns
		gns.Approve(poolAddr, consts.UINT64_MAX)
		// 3. Mint position
		beforeWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
		beforeGnsBalance := gns.BalanceOf(bobAddr)
		id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
			token1Path,
			fee,
			lowerTick,
			upperTick,
			amount0Desired,
			amount1Desired,
			amount0Min,
			amount1Min,
			maxTimeout,
			bobAddr,
			bobAddr,
			referrerAddr)
		uassert.Equal(t, uint64(2), id)
		uassert.Equal(t, "99939940", amount0Str)
		uassert.Equal(t, amount1Desired, amount1Str)
		uassert.Equal(t, "224838465", liquidityStr)
		pool := pl.GetPool(token0Path, token1Path, fee)
		sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
		sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
		sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
		amount0U256 := u256.MustFromDecimal(amount0Desired)
		amount1U256 := u256.MustFromDecimal(amount1Desired)
		calculatedLiquidity := common.GetLiquidityForAmounts(
			sqrtPriceX96,
			sqrtRatioAX96,
			sqrtRatioBX96,
			amount0U256,
			amount1U256,
		)
		uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
		liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
		calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
		afterWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
		afterGnsBalance := gns.BalanceOf(bobAddr)
		uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
		uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

		posIdTwo := ApiGetPosition(id)
		uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":2,"burned":false,"owner":"g1vfhkyh6lta047h6lta047h6lta047h6l03vdhu","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"99939940","token1Balance":"23027406","calculatedToken0Balance":"99939939","calculatedToken1Balance":"23027405","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
			posIdTwo)
		poolInfo := pl.ApiGetPool(pool.PoolPath())
		uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"149922931","token1Balance":"73027406","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"394941880","ticks":{"-2160":{"liquidityGross":"224838465","liquidityNet":"224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"11760":{"liquidityGross":"224838465","liquidityNet":"-224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","token0Owed":"0","token1Owed":"0"},{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
			poolInfo)
	})

	t.Run("Swap gns -> wugnot", func(t *testing.T) {
		inputToken := "gno.land/r/gnoswap/v1/gns"
		outputToken := "gno.land/r/demo/wugnot"
		amountIn := "20000000"
		routePath := "gno.land/r/gnoswap/v1/gns:gno.land/r/demo/wugnot:3000"
		quote := "100"
		amountOutMin := "15000000"
		deadline := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. Approve wugnot
		cross(wugnot.Approve)(routerAddr, consts.UINT64_MAX)
		// 2. Approve gns
		gns.Approve(routerAddr, consts.UINT64_MAX)
		// 3. Mint position
		beforeWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		beforeGnsBalance := gns.BalanceOf(adminAddr)

		amountIn, amountOut := cross(rr.ExactInSwapRoute)(
			inputToken,
			outputToken,
			amountIn,
			routePath,
			quote,
			amountOutMin,
			deadline,
			referrerAddr,
		)
		afterWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		afterGnsBalance := gns.BalanceOf(adminAddr)
		uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amountIn)
		num, _ := strconv.ParseInt(amountOut, 10, 64)
		if num < 0 {
			num = num * (-1)
		}
		uassert.Equal(t, strconv.FormatUint(afterWugnotBalance-beforeWugnotBalance, 10), strconv.FormatInt(num, 10))

		posIdOne := MustGetPosition(uint64(1))
		poolForOne := cross(pl.GetPoolFromPoolPath)(posIdOne.poolKey)
		calculatedToken0BalanceForOne, calculatedToken1BalanceForOne := common.GetAmountsForLiquidity(
			poolForOne.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickUpper),
			posIdOne.liquidity,
		)
		unclaimedFee0ForOne := i256.Zero()
		unclaimedFee1ForOne := i256.Zero()
		burned := isBurned(uint64(1))
		if !burned {
			unclaimedFee0ForOne, unclaimedFee1ForOne = unclaimedFee(uint64(1))
		}

		posIdTwo := MustGetPosition(uint64(2))
		poolForTwo := cross(pl.GetPoolFromPoolPath)(posIdTwo.poolKey)
		calculatedToken0BalanceForTwo, calculatedToken1BalanceForTwo := common.GetAmountsForLiquidity(
			poolForTwo.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickUpper),
			posIdTwo.liquidity,
		)
		unclaimedFee0ForTwo := i256.Zero()
		unclaimedFee1ForTwo := i256.Zero()
		burned = isBurned(uint64(2))
		if !burned {
			unclaimedFee0ForTwo, unclaimedFee1ForTwo = unclaimedFee(uint64(2))
		}

		token0BalanceForOne := i256.MustFromDecimal(calculatedToken0BalanceForOne)
		token1BalanceForOne := i256.MustFromDecimal(calculatedToken1BalanceForOne)
		token0BalanceForTwo := i256.MustFromDecimal(calculatedToken0BalanceForTwo)
		token1BalanceForTwo := i256.MustFromDecimal(calculatedToken1BalanceForTwo)
		sumOfToken0BalanceByPosition := i256.Zero().Add(token0BalanceForOne, token0BalanceForTwo)
		sumOfToken1BalanceByPosition := i256.Zero().Add(token1BalanceForOne, token1BalanceForTwo)
		sumOfToken0UnClaimed := i256.Zero().Add(unclaimedFee0ForOne, unclaimedFee0ForTwo)
		sumOfToken1UnClaimed := i256.Zero().Add(unclaimedFee1ForOne, unclaimedFee1ForTwo)

		sumOfToken0Balance := i256.Zero().Add(sumOfToken0BalanceByPosition, sumOfToken0UnClaimed)
		sumOfToken1Balance := i256.Zero().Add(sumOfToken1BalanceByPosition, sumOfToken1UnClaimed)

		pool := pl.GetPool(outputToken, inputToken, fee)

		poolBalanceToken0 := pool.BalanceToken0()
		poolBalanceToken1 := pool.BalanceToken1()

		diffToken0 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken0), sumOfToken0Balance)
		diffToken1 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken1), sumOfToken1Balance)
		uassert.Equal(t, true, diffToken0.Lt(i256.NewInt(10)))
		uassert.Equal(t, true, diffToken1.Lt(i256.NewInt(10)))
	})
}

func TestPositionBalanceCompareWithPoolBalanceWhenPositionBurnAndIncrease(t *testing.T) {
	aliceAddr := testutils.TestAddress("alice")
	bobAddr := testutils.TestAddress("bob")
	adminAddr, _ := access.GetAddress(access.ROLE_ADMIN)
	poolAddr, _ := access.GetAddress(access.ROLE_POOL)
	routerAddr, _ := access.GetAddress(access.ROLE_ROUTER)
	positionAddr, _ := access.GetAddress(access.ROLE_POSITION)

	aliceRealm := std.NewUserRealm(aliceAddr)
	bobRealm := std.NewUserRealm(bobAddr)
	adminRealm := std.NewUserRealm(adminAddr)

	defaultTick := int32(1)
	token0Path := "gno.land/r/demo/wugnot"
	token1Path := "gno.land/r/gnoswap/v1/gns"
	fee := uint32(3000)

	t.Run("distribute gns token ", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000000)
		if gns.BalanceOf(aliceAddr) < tokenAmountForDistribute {
			testing.SetRealm(adminRealm)
			gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
			uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(aliceAddr))
		}

		if gns.BalanceOf(bobAddr) < tokenAmountForDistribute {
			testing.SetRealm(adminRealm)
			gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
			uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(bobAddr))
		}
	})

	t.Run("distribute wugnot token ", func(t *testing.T) {
		tokenAmountForDistribute := int64(1000000000000)
		fullTokenAmount := tokenAmountForDistribute * 1000000
		if cross(wugnot.BalanceOf)(aliceAddr) == uint64(0) {
			testing.SetOriginCaller(adminAddr)
			newCoins := std.Coins{{"ugnot", fullTokenAmount}}
			testing.IssueCoins(adminAddr, newCoins)
			testing.SetOriginSend(newCoins)
			banker := std.NewBanker(std.BankerTypeRealmSend)
			banker.SendCoins(adminAddr, consts.WUGNOT_ADDR, newCoins)
			cross(wugnot.Deposit)()
			cross(wugnot.Transfer)(aliceAddr, uint64(tokenAmountForDistribute))
			uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(aliceAddr))
		}
		if cross(wugnot.BalanceOf)(bobAddr) == uint64(0) {
			testing.SetOriginCaller(adminAddr)
			newCoins := std.Coins{{"ugnot", fullTokenAmount}}
			testing.IssueCoins(adminAddr, newCoins)
			testing.SetOriginSend(newCoins)
			banker := std.NewBanker(std.BankerTypeRealmSend)
			banker.SendCoins(adminAddr, consts.WUGNOT_ADDR, newCoins)
			cross(wugnot.Deposit)()
			cross(wugnot.Transfer)(bobAddr, uint64(tokenAmountForDistribute))
			uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(aliceAddr))
		}
	})

	t.Run("create pool - wugnot-gns-3000", func(t *testing.T) {
		poolPath := pl.GetPoolPath(token0Path, token1Path, fee)
		if !pl.DoesPoolPathExist(poolPath) {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 2. Create pool
			pl.CreatePool(token0Path, token1Path, fee, common.TickMathGetSqrtRatioAtTick(defaultTick).ToString())
			poolPath := pl.GetPoolPath(token0Path, token1Path, fee)
			pool := cross(pl.GetPoolFromPoolPath)(poolPath)
			uassert.Equal(t, poolPath, pool.PoolPath())
			uassert.Equal(t, token0Path, pool.Token0Path())
			uassert.Equal(t, token1Path, pool.Token1Path())
			uassert.Equal(t, fee, pool.Fee())
			uassert.Equal(t, "0", pool.BalanceToken0().ToString())
			uassert.Equal(t, "0", pool.BalanceToken1().ToString())
			uassert.Equal(t, int32(60), pool.TickSpacing())
			uassert.Equal(t, "11505743598341114571880798222544994", pool.MaxLiquidityPerTick().ToString())
			uassert.Equal(t, "79232123823359799118286999568", pool.Slot0SqrtPriceX96().ToString())
			uassert.Equal(t, int32(1), common.TickMathGetTickAtSqrtRatio(pool.Slot0SqrtPriceX96()))
			uassert.Equal(t, int32(1), pool.Slot0Tick())
			uassert.Equal(t, uint8(0), pool.Slot0FeeProtocol())
			uassert.Equal(t, true, pool.Slot0Unlocked())
			uassert.Equal(t, "0", pool.FeeGrowthGlobal0X128().ToString())
			uassert.Equal(t, "0", pool.FeeGrowthGlobal1X128().ToString())
			uassert.Equal(t, "0", pool.ProtocolFeesToken0().ToString())
			uassert.Equal(t, "0", pool.ProtocolFeesToken1().ToString())
			uassert.Equal(t, "0", pool.Liquidity().ToString())

			poolInfo := pl.ApiGetPool(pl.GetPoolPath(token0Path, token1Path, fee))
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"0","token1Balance":"0","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"0","ticks":{},"tickBitmaps":{},"positions":[]}}`,
				poolInfo)
		}
	})

	t.Run("Distribute Gns Token", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000)
		if gns.BalanceOf(aliceAddr) > tokenAmountForDistribute {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. transfer gns
			gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
		}
		if gns.BalanceOf(bobAddr) > tokenAmountForDistribute {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. transfer gns
			gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
		}
	})

	t.Run("Mint New Position", func(t *testing.T) {
		lowerTick := int32(-6960)
		upperTick := int32(6960)
		amount0Desired := "50000000"
		amount1Desired := "50000000"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(1)

		_, exist := GetPosition(positionId)
		if !exist {
			// 0. Set realm to alice
			testing.SetRealm(aliceRealm)
			// 1. Approve wugnot
			cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
			// 2. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 3. Mint position
			beforeWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
			beforeGnsBalance := gns.BalanceOf(aliceAddr)
			id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
				token1Path,
				fee,
				lowerTick,
				upperTick,
				amount0Desired,
				amount1Desired,
				amount0Min,
				amount1Min,
				maxTimeout,
				aliceAddr,
				aliceAddr,
				referrerAddr)
			uassert.Equal(t, uint64(1), id)
			uassert.Equal(t, "49982991", amount0Str)
			uassert.Equal(t, amount1Desired, amount1Str)
			uassert.Equal(t, "170103415", liquidityStr)

			pool := pl.GetPool(token0Path, token1Path, fee)
			sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
			sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
			sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
			amount0U256 := u256.MustFromDecimal(amount0Desired)
			amount1U256 := u256.MustFromDecimal(amount1Desired)
			calculatedLiquidity := common.GetLiquidityForAmounts(
				sqrtPriceX96,
				sqrtRatioAX96,
				sqrtRatioBX96,
				amount0U256,
				amount1U256,
			)
			uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
			liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
			calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
			afterWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
			afterGnsBalance := gns.BalanceOf(aliceAddr)
			uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
			uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

			posIdOne := ApiGetPosition(id)
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":1,"burned":false,"owner":"g1v9kxjcm9ta047h6lta047h6lta047h6lzd40gh","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"49982991","token1Balance":"50000000","calculatedToken0Balance":"49982990","calculatedToken1Balance":"49999999","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
				posIdOne)

			poolInfo := pl.ApiGetPool(pool.PoolPath())
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"49982991","token1Balance":"50000000","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"170103415","ticks":{"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
				poolInfo)
		}
	})

	t.Run("Mint New Position - 2", func(t *testing.T) {
		lowerTick := int32(-2160)
		upperTick := int32(11760)
		amount0Desired := "99999999"
		amount1Desired := "23027406"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(2)

		_, exist := GetPosition(positionId)
		if !exist {
			// 0. Set realm to bob
			testing.SetRealm(bobRealm)
			// 1. Approve wugnot
			cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
			// 2. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 3. Mint position
			beforeWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
			beforeGnsBalance := gns.BalanceOf(bobAddr)
			id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
				token1Path,
				fee,
				lowerTick,
				upperTick,
				amount0Desired,
				amount1Desired,
				amount0Min,
				amount1Min,
				maxTimeout,
				bobAddr,
				bobAddr,
				referrerAddr)
			uassert.Equal(t, uint64(2), id)
			uassert.Equal(t, "99939940", amount0Str)
			uassert.Equal(t, amount1Desired, amount1Str)
			uassert.Equal(t, "224838465", liquidityStr)
			pool := pl.GetPool(token0Path, token1Path, fee)
			sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
			sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
			sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
			amount0U256 := u256.MustFromDecimal(amount0Desired)
			amount1U256 := u256.MustFromDecimal(amount1Desired)
			calculatedLiquidity := common.GetLiquidityForAmounts(
				sqrtPriceX96,
				sqrtRatioAX96,
				sqrtRatioBX96,
				amount0U256,
				amount1U256,
			)
			uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
			liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
			calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
			afterWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
			afterGnsBalance := gns.BalanceOf(bobAddr)
			uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
			uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

			posIdTwo := ApiGetPosition(id)
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":2,"burned":false,"owner":"g1vfhkyh6lta047h6lta047h6lta047h6l03vdhu","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"99939940","token1Balance":"23027406","calculatedToken0Balance":"99939939","calculatedToken1Balance":"23027405","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
				posIdTwo)
			poolInfo := pl.ApiGetPool(pool.PoolPath())
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"149922931","token1Balance":"73027406","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"394941880","ticks":{"-2160":{"liquidityGross":"224838465","liquidityNet":"224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"11760":{"liquidityGross":"224838465","liquidityNet":"-224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","token0Owed":"0","token1Owed":"0"},{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
				poolInfo)
		}
	})

	t.Run("Swap gns -> wugnot", func(t *testing.T) {
		inputToken := "gno.land/r/gnoswap/v1/gns"
		outputToken := "gno.land/r/demo/wugnot"
		amountIn := "20000000"
		routePath := "gno.land/r/gnoswap/v1/gns:gno.land/r/demo/wugnot:3000"
		quote := "100"
		amountOutMin := "15000000"
		deadline := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. Approve wugnot
		cross(wugnot.Approve)(routerAddr, consts.UINT64_MAX)
		// 2. Approve gns
		gns.Approve(routerAddr, consts.UINT64_MAX)
		// 3. Mint position
		beforeWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		beforeGnsBalance := gns.BalanceOf(adminAddr)

		amountIn, amountOut := cross(rr.ExactInSwapRoute)(
			inputToken,
			outputToken,
			amountIn,
			routePath,
			quote,
			amountOutMin,
			deadline,
			referrerAddr,
		)
		afterWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		afterGnsBalance := gns.BalanceOf(adminAddr)
		uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amountIn)
		num, _ := strconv.ParseInt(amountOut, 10, 64)
		if num < 0 {
			num = num * (-1)
		}
		uassert.Equal(t, strconv.FormatUint(afterWugnotBalance-beforeWugnotBalance, 10), strconv.FormatInt(num, 10))

		posIdOne := MustGetPosition(uint64(1))
		poolForOne := cross(pl.GetPoolFromPoolPath)(posIdOne.poolKey)
		calculatedToken0BalanceForOne, calculatedToken1BalanceForOne := common.GetAmountsForLiquidity(
			poolForOne.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickUpper),
			posIdOne.liquidity,
		)
		unclaimedFee0ForOne := i256.Zero()
		unclaimedFee1ForOne := i256.Zero()
		burned := isBurned(uint64(1))
		if !burned {
			unclaimedFee0ForOne, unclaimedFee1ForOne = unclaimedFee(uint64(1))
		}

		posIdTwo := MustGetPosition(uint64(2))
		poolForTwo := cross(pl.GetPoolFromPoolPath)(posIdTwo.poolKey)
		calculatedToken0BalanceForTwo, calculatedToken1BalanceForTwo := common.GetAmountsForLiquidity(
			poolForTwo.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickUpper),
			posIdTwo.liquidity,
		)
		unclaimedFee0ForTwo := i256.Zero()
		unclaimedFee1ForTwo := i256.Zero()
		burned = isBurned(uint64(2))
		if !burned {
			unclaimedFee0ForTwo, unclaimedFee1ForTwo = unclaimedFee(uint64(2))
		}

		token0BalanceForOne := i256.MustFromDecimal(calculatedToken0BalanceForOne)
		token1BalanceForOne := i256.MustFromDecimal(calculatedToken1BalanceForOne)
		token0BalanceForTwo := i256.MustFromDecimal(calculatedToken0BalanceForTwo)
		token1BalanceForTwo := i256.MustFromDecimal(calculatedToken1BalanceForTwo)
		sumOfToken0BalanceByPosition := i256.Zero().Add(token0BalanceForOne, token0BalanceForTwo)
		sumOfToken1BalanceByPosition := i256.Zero().Add(token1BalanceForOne, token1BalanceForTwo)
		sumOfToken0UnClaimed := i256.Zero().Add(unclaimedFee0ForOne, unclaimedFee0ForTwo)
		sumOfToken1UnClaimed := i256.Zero().Add(unclaimedFee1ForOne, unclaimedFee1ForTwo)

		sumOfToken0Balance := i256.Zero().Add(sumOfToken0BalanceByPosition, sumOfToken0UnClaimed)
		sumOfToken1Balance := i256.Zero().Add(sumOfToken1BalanceByPosition, sumOfToken1UnClaimed)

		pool := pl.GetPool(outputToken, inputToken, fee)

		poolBalanceToken0 := pool.BalanceToken0()
		poolBalanceToken1 := pool.BalanceToken1()

		diffToken0 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken0), sumOfToken0Balance)
		diffToken1 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken1), sumOfToken1Balance)
		uassert.Equal(t, true, diffToken0.Lt(i256.NewInt(10)))
		uassert.Equal(t, true, diffToken1.Lt(i256.NewInt(10)))
	})

	t.Run("Burn position #1 ", func(t *testing.T) {
		// 0. Set realm to alice
		testing.SetRealm(aliceRealm)

		beforeWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
		beforeGnsBalance := gns.BalanceOf(aliceAddr)
		liquidity := "170103415"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()

		position, _ := GetPosition(uint64(1))
		uassert.Equal(t, "49982991", position.token0Balance.ToString())
		uassert.Equal(t, "50000000", position.token1Balance.ToString())

		positionId, liquidityStr, fee0, fee1, amount0Str, amount1Str, poolPath := DecreaseLiquidity(uint64(1), liquidity, amount0Min, amount1Min, maxTimeout, false)
		afterWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
		afterGnsBalance := gns.BalanceOf(aliceAddr)
		amount0, _ := strconv.ParseUint(amount0Str, 10, 64)
		amount0Fee, _ := strconv.ParseUint(fee0, 10, 64)
		amount1, _ := strconv.ParseUint(amount1Str, 10, 64)
		amount1Fee, _ := strconv.ParseUint(fee1, 10, 64)
		uassert.Equal(t, strconv.FormatUint(afterWugnotBalance-beforeWugnotBalance, 10),
			strconv.FormatUint(amount0+amount0Fee, 10))
		uassert.Equal(t, strconv.FormatUint(afterGnsBalance-beforeGnsBalance, 10),
			strconv.FormatUint(amount1+amount1Fee, 10))

		position, _ = GetPosition(uint64(1))
		uassert.Equal(t, "0", position.token0Balance.ToString())
		uassert.Equal(t, "0", position.token1Balance.ToString())
	})

	t.Run("distribute ugnot token ", func(t *testing.T) {
		tokenAmountForDistribute := int64(1000000000000)
		fullTokenAmount := tokenAmountForDistribute * 1000000

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)

		// 1. transfer ugnot
		testing.SetOriginCaller(adminAddr)
		newCoins := std.Coins{{"ugnot", fullTokenAmount}}
		distributeCoins := std.Coins{{"ugnot", tokenAmountForDistribute}}
		testing.IssueCoins(adminAddr, newCoins)
		testing.SetOriginSend(newCoins)
		banker := std.NewBanker(std.BankerTypeRealmSend)
		banker.SendCoins(adminAddr, aliceAddr, distributeCoins)
		banker.SendCoins(adminAddr, bobAddr, distributeCoins)
	})

	t.Run("IncreaseLiquidity #1 ", func(t *testing.T) {
		amount0Desired := "50000000"
		amount1Desired := "50000000"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(1)

		// Add Liquidity
		testing.SetRealm(aliceRealm)
		testing.SetOriginCaller(aliceAddr)
		addAmount, err := strconv.ParseInt(amount0Desired, 10, 64)
		if err != nil {
			t.Errorf("failed to parse amount0Requested: %v", err)
		}
		newCoinsForAdd := std.Coins{{"ugnot", addAmount}}
		testing.SetOriginSend(newCoinsForAdd)
		banker := std.NewBanker(std.BankerTypeRealmSend)
		banker.SendCoins(aliceAddr, positionAddr, newCoinsForAdd)
		testing.SetRealm(aliceRealm)
		cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
		gns.Approve(poolAddr, consts.UINT64_MAX)
		cross(wugnot.Approve)(positionAddr, consts.UINT64_MAX)

		testing.SetRealm(aliceRealm)
		positionId, liquidity, amount0Str, amount1Str, poolPath := IncreaseLiquidity(positionId, amount0Desired, amount1Desired, amount0Min, amount1Min, maxTimeout)
		position, _ := GetPosition(positionId)
		uassert.Equal(t, "25591774", amount0Str)
		uassert.Equal(t, "50000000", amount1Str)
		uassert.Equal(t, "126609292", liquidity)
		uassert.Equal(t, amount0Str, position.token0Balance.ToString())
		uassert.Equal(t, amount1Str, position.token1Balance.ToString())
	})
}

func TestPositionBalanceCompareWithPoolBalanceWhenPositionIncrease(t *testing.T) {
	aliceAddr := testutils.TestAddress("alice")
	bobAddr := testutils.TestAddress("bob")
	adminAddr, _ := access.GetAddress(access.ROLE_ADMIN)
	poolAddr, _ := access.GetAddress(access.ROLE_POOL)
	routerAddr, _ := access.GetAddress(access.ROLE_ROUTER)
	positionAddr, _ := access.GetAddress(access.ROLE_POSITION)

	aliceRealm := std.NewUserRealm(aliceAddr)
	bobRealm := std.NewUserRealm(bobAddr)
	adminRealm := std.NewUserRealm(adminAddr)

	defaultTick := int32(1)
	token0Path := "gno.land/r/demo/wugnot"
	token1Path := "gno.land/r/gnoswap/v1/gns"
	fee := uint32(3000)

	t.Run("distribute gns token ", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000000)
		if gns.BalanceOf(aliceAddr) < tokenAmountForDistribute {
			testing.SetRealm(adminRealm)
			gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
			uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(aliceAddr))
		}

		if gns.BalanceOf(bobAddr) < tokenAmountForDistribute {
			testing.SetRealm(adminRealm)
			gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
			uassert.Equal(t, tokenAmountForDistribute, gns.BalanceOf(bobAddr))
		}
	})

	t.Run("distribute wugnot token ", func(t *testing.T) {
		tokenAmountForDistribute := int64(1000000000000)
		fullTokenAmount := tokenAmountForDistribute * 1000000
		if cross(wugnot.BalanceOf)(aliceAddr) == uint64(0) {
			testing.SetOriginCaller(adminAddr)
			newCoins := std.Coins{{"ugnot", fullTokenAmount}}
			testing.IssueCoins(adminAddr, newCoins)
			testing.SetOriginSend(newCoins)
			banker := std.NewBanker(std.BankerTypeRealmSend)
			banker.SendCoins(adminAddr, consts.WUGNOT_ADDR, newCoins)
			cross(wugnot.Deposit)()
			cross(wugnot.Transfer)(aliceAddr, uint64(tokenAmountForDistribute))
			uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(aliceAddr))
		}
		if cross(wugnot.BalanceOf)(bobAddr) == uint64(0) {
			testing.SetOriginCaller(adminAddr)
			newCoins := std.Coins{{"ugnot", fullTokenAmount}}
			testing.IssueCoins(adminAddr, newCoins)
			testing.SetOriginSend(newCoins)
			banker := std.NewBanker(std.BankerTypeRealmSend)
			banker.SendCoins(adminAddr, consts.WUGNOT_ADDR, newCoins)
			cross(wugnot.Deposit)()
			cross(wugnot.Transfer)(bobAddr, uint64(tokenAmountForDistribute))
			uassert.Equal(t, uint64(tokenAmountForDistribute), cross(wugnot.BalanceOf)(aliceAddr))
		}
	})

	t.Run("create pool - wugnot-gns-3000", func(t *testing.T) {
		poolPath := pl.GetPoolPath(token0Path, token1Path, fee)
		if !pl.DoesPoolPathExist(poolPath) {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 2. Create pool
			pl.CreatePool(token0Path, token1Path, fee, common.TickMathGetSqrtRatioAtTick(defaultTick).ToString())
			poolPath := pl.GetPoolPath(token0Path, token1Path, fee)
			pool := cross(pl.GetPoolFromPoolPath)(poolPath)
			uassert.Equal(t, poolPath, pool.PoolPath())
			uassert.Equal(t, token0Path, pool.Token0Path())
			uassert.Equal(t, token1Path, pool.Token1Path())
			uassert.Equal(t, fee, pool.Fee())
			uassert.Equal(t, "0", pool.BalanceToken0().ToString())
			uassert.Equal(t, "0", pool.BalanceToken1().ToString())
			uassert.Equal(t, int32(60), pool.TickSpacing())
			uassert.Equal(t, "11505743598341114571880798222544994", pool.MaxLiquidityPerTick().ToString())
			uassert.Equal(t, "79232123823359799118286999568", pool.Slot0SqrtPriceX96().ToString())
			uassert.Equal(t, int32(1), common.TickMathGetTickAtSqrtRatio(pool.Slot0SqrtPriceX96()))
			uassert.Equal(t, int32(1), pool.Slot0Tick())
			uassert.Equal(t, uint8(0), pool.Slot0FeeProtocol())
			uassert.Equal(t, true, pool.Slot0Unlocked())
			uassert.Equal(t, "0", pool.FeeGrowthGlobal0X128().ToString())
			uassert.Equal(t, "0", pool.FeeGrowthGlobal1X128().ToString())
			uassert.Equal(t, "0", pool.ProtocolFeesToken0().ToString())
			uassert.Equal(t, "0", pool.ProtocolFeesToken1().ToString())
			uassert.Equal(t, "0", pool.Liquidity().ToString())

			poolInfo := pl.ApiGetPool(pl.GetPoolPath(token0Path, token1Path, fee))
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"0","token1Balance":"0","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"0","ticks":{},"tickBitmaps":{},"positions":[]}}`,
				poolInfo)
		}
	})

	t.Run("Distribute Gns Token", func(t *testing.T) {
		tokenAmountForDistribute := uint64(1000000000)
		if gns.BalanceOf(aliceAddr) > tokenAmountForDistribute {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. transfer gns
			gns.Transfer(cross, aliceAddr, tokenAmountForDistribute)
		}
		if gns.BalanceOf(bobAddr) > tokenAmountForDistribute {
			// 0. Set realm to admin
			testing.SetRealm(adminRealm)
			// 1. transfer gns
			gns.Transfer(cross, bobAddr, tokenAmountForDistribute)
		}
	})

	t.Run("Mint New Position", func(t *testing.T) {
		lowerTick := int32(-6960)
		upperTick := int32(6960)
		amount0Desired := "50000000"
		amount1Desired := "50000000"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(1)

		_, exist := GetPosition(positionId)
		if !exist {
			// 0. Set realm to alice
			testing.SetRealm(aliceRealm)
			// 1. Approve wugnot
			cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
			// 2. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 3. Mint position
			beforeWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
			beforeGnsBalance := gns.BalanceOf(aliceAddr)
			id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
				token1Path,
				fee,
				lowerTick,
				upperTick,
				amount0Desired,
				amount1Desired,
				amount0Min,
				amount1Min,
				maxTimeout,
				aliceAddr,
				aliceAddr,
				referrerAddr)
			uassert.Equal(t, uint64(1), id)
			uassert.Equal(t, "49982991", amount0Str)
			uassert.Equal(t, amount1Desired, amount1Str)
			uassert.Equal(t, "170103415", liquidityStr)

			pool := pl.GetPool(token0Path, token1Path, fee)
			sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
			sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
			sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
			amount0U256 := u256.MustFromDecimal(amount0Desired)
			amount1U256 := u256.MustFromDecimal(amount1Desired)
			calculatedLiquidity := common.GetLiquidityForAmounts(
				sqrtPriceX96,
				sqrtRatioAX96,
				sqrtRatioBX96,
				amount0U256,
				amount1U256,
			)
			uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
			liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
			calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
			afterWugnotBalance := cross(wugnot.BalanceOf)(aliceAddr)
			afterGnsBalance := gns.BalanceOf(aliceAddr)
			uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
			uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

			posIdOne := ApiGetPosition(id)
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":1,"burned":false,"owner":"g1v9kxjcm9ta047h6lta047h6lta047h6lzd40gh","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"49982991","token1Balance":"50000000","calculatedToken0Balance":"49982990","calculatedToken1Balance":"49999999","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
				posIdOne)

			poolInfo := pl.ApiGetPool(pool.PoolPath())
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"49982991","token1Balance":"50000000","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"170103415","ticks":{"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
				poolInfo)
		}
	})

	t.Run("Mint New Position - 2", func(t *testing.T) {
		lowerTick := int32(-2160)
		upperTick := int32(11760)
		amount0Desired := "99999999"
		amount1Desired := "23027406"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(2)

		_, exist := GetPosition(positionId)
		if !exist {
			// 0. Set realm to bob
			testing.SetRealm(bobRealm)
			// 1. Approve wugnot
			cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
			// 2. Approve gns
			gns.Approve(poolAddr, consts.UINT64_MAX)
			// 3. Mint position
			beforeWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
			beforeGnsBalance := gns.BalanceOf(bobAddr)
			id, liquidityStr, amount0Str, amount1Str := Mint(token0Path,
				token1Path,
				fee,
				lowerTick,
				upperTick,
				amount0Desired,
				amount1Desired,
				amount0Min,
				amount1Min,
				maxTimeout,
				bobAddr,
				bobAddr,
				referrerAddr)
			uassert.Equal(t, uint64(2), id)
			uassert.Equal(t, "99939940", amount0Str)
			uassert.Equal(t, amount1Desired, amount1Str)
			uassert.Equal(t, "224838465", liquidityStr)
			pool := pl.GetPool(token0Path, token1Path, fee)
			sqrtPriceX96 := new(u256.Uint).Set(pool.Slot0SqrtPriceX96())
			sqrtRatioAX96 := common.TickMathGetSqrtRatioAtTick(lowerTick)
			sqrtRatioBX96 := common.TickMathGetSqrtRatioAtTick(upperTick)
			amount0U256 := u256.MustFromDecimal(amount0Desired)
			amount1U256 := u256.MustFromDecimal(amount1Desired)
			calculatedLiquidity := common.GetLiquidityForAmounts(
				sqrtPriceX96,
				sqrtRatioAX96,
				sqrtRatioBX96,
				amount0U256,
				amount1U256,
			)
			uassert.Equal(t, calculatedLiquidity.ToString(), liquidityStr)
			liquidityFroPositionOne := u256.MustFromDecimal(liquidityStr)
			calculatedAmount0, calculatedAmount1 := common.GetAmountsForLiquidity(sqrtPriceX96, sqrtRatioAX96, sqrtRatioBX96, liquidityFroPositionOne)
			afterWugnotBalance := cross(wugnot.BalanceOf)(bobAddr)
			afterGnsBalance := gns.BalanceOf(bobAddr)
			uassert.Equal(t, strconv.FormatUint(beforeWugnotBalance-afterWugnotBalance, 10), amount0Str)
			uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amount1Str)

			posIdTwo := ApiGetPosition(id)
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":[{"lpPositionId":2,"burned":false,"owner":"g1vfhkyh6lta047h6lta047h6lta047h6l03vdhu","operator":"g100000000000000000000000000000000dnmcnx","poolKey":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","feeGrowthInside0LastX128":"0","feeGrowthInside1LastX128":"0","token0Owed":"0","token1Owed":"0","token0Balance":"99939940","token1Balance":"23027406","calculatedToken0Balance":"99939939","calculatedToken1Balance":"23027405","fee0Unclaimed":"0","fee1Unclaimed":"0"}]}`,
				posIdTwo)
			poolInfo := pl.ApiGetPool(pool.PoolPath())
			uassert.Equal(t, `{"stat":{"height":123,"timestamp":1234567890},"response":{"poolPath":"gno.land/r/demo/wugnot:gno.land/r/gnoswap/v1/gns:3000","token0Path":"gno.land/r/demo/wugnot","token1Path":"gno.land/r/gnoswap/v1/gns","token0Balance":"149922931","token1Balance":"73027406","fee":3000,"tickSpacing":60,"maxLiquidityPerTick":"11505743598341114571880798222544994","sqrtPriceX96":"79232123823359799118286999568","tick":1,"feeProtocol":0,"unlocked":true,"feeGrowthGlobal0X128":"0","feeGrowthGlobal1X128":"0","token0ProtocolFee":"0","token1ProtocolFee":"0","liquidity":"394941880","ticks":{"-2160":{"liquidityGross":"224838465","liquidityNet":"224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"-6960":{"liquidityGross":"170103415","liquidityNet":"170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"11760":{"liquidityGross":"224838465","liquidityNet":"-224838465","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true},"6960":{"liquidityGross":"170103415","liquidityNet":"-170103415","feeGrowthOutside0X128":"0","feeGrowthOutside1X128":"0","tickCumulativeOutside":0,"secondsPerLiquidityOutsideX":"0","secondsOutside":0,"initialized":true}},"tickBitmaps":{},"positions":[{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-2160,"tickUpper":11760,"liquidity":"224838465","token0Owed":"0","token1Owed":"0"},{"owner":"g1q646ctzhvn60v492x8ucvyqnrj2w30cwh6efk5","tickLower":-6960,"tickUpper":6960,"liquidity":"170103415","token0Owed":"0","token1Owed":"0"}]}}`,
				poolInfo)
		}
	})

	t.Run("Swap gns -> wugnot", func(t *testing.T) {
		inputToken := "gno.land/r/gnoswap/v1/gns"
		outputToken := "gno.land/r/demo/wugnot"
		amountIn := "20000000"
		routePath := "gno.land/r/gnoswap/v1/gns:gno.land/r/demo/wugnot:3000"
		quote := "100"
		amountOutMin := "15000000"
		deadline := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)
		// 1. Approve wugnot
		cross(wugnot.Approve)(routerAddr, consts.UINT64_MAX)
		// 2. Approve gns
		gns.Approve(routerAddr, consts.UINT64_MAX)
		// 3. Mint position
		beforeWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		beforeGnsBalance := gns.BalanceOf(adminAddr)

		amountIn, amountOut := cross(rr.ExactInSwapRoute)(
			inputToken,
			outputToken,
			amountIn,
			routePath,
			quote,
			amountOutMin,
			deadline,
			referrerAddr,
		)
		afterWugnotBalance := cross(wugnot.BalanceOf)(adminAddr)
		afterGnsBalance := gns.BalanceOf(adminAddr)
		uassert.Equal(t, strconv.FormatUint(beforeGnsBalance-afterGnsBalance, 10), amountIn)
		num, _ := strconv.ParseInt(amountOut, 10, 64)
		if num < 0 {
			num = num * (-1)
		}
		uassert.Equal(t, strconv.FormatUint(afterWugnotBalance-beforeWugnotBalance, 10), strconv.FormatInt(num, 10))

		posIdOne := MustGetPosition(uint64(1))
		poolForOne := cross(pl.GetPoolFromPoolPath)(posIdOne.poolKey)
		calculatedToken0BalanceForOne, calculatedToken1BalanceForOne := common.GetAmountsForLiquidity(
			poolForOne.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdOne.tickUpper),
			posIdOne.liquidity,
		)
		unclaimedFee0ForOne := i256.Zero()
		unclaimedFee1ForOne := i256.Zero()
		burned := isBurned(uint64(1))
		if !burned {
			unclaimedFee0ForOne, unclaimedFee1ForOne = unclaimedFee(uint64(1))
		}

		posIdTwo := MustGetPosition(uint64(2))
		poolForTwo := cross(pl.GetPoolFromPoolPath)(posIdTwo.poolKey)
		calculatedToken0BalanceForTwo, calculatedToken1BalanceForTwo := common.GetAmountsForLiquidity(
			poolForTwo.Slot0SqrtPriceX96(),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickLower),
			common.TickMathGetSqrtRatioAtTick(posIdTwo.tickUpper),
			posIdTwo.liquidity,
		)
		unclaimedFee0ForTwo := i256.Zero()
		unclaimedFee1ForTwo := i256.Zero()
		burned = isBurned(uint64(2))
		if !burned {
			unclaimedFee0ForTwo, unclaimedFee1ForTwo = unclaimedFee(uint64(2))
		}

		token0BalanceForOne := i256.MustFromDecimal(calculatedToken0BalanceForOne)
		token1BalanceForOne := i256.MustFromDecimal(calculatedToken1BalanceForOne)
		token0BalanceForTwo := i256.MustFromDecimal(calculatedToken0BalanceForTwo)
		token1BalanceForTwo := i256.MustFromDecimal(calculatedToken1BalanceForTwo)
		sumOfToken0BalanceByPosition := i256.Zero().Add(token0BalanceForOne, token0BalanceForTwo)
		sumOfToken1BalanceByPosition := i256.Zero().Add(token1BalanceForOne, token1BalanceForTwo)
		sumOfToken0UnClaimed := i256.Zero().Add(unclaimedFee0ForOne, unclaimedFee0ForTwo)
		sumOfToken1UnClaimed := i256.Zero().Add(unclaimedFee1ForOne, unclaimedFee1ForTwo)

		sumOfToken0Balance := i256.Zero().Add(sumOfToken0BalanceByPosition, sumOfToken0UnClaimed)
		sumOfToken1Balance := i256.Zero().Add(sumOfToken1BalanceByPosition, sumOfToken1UnClaimed)

		pool := pl.GetPool(outputToken, inputToken, fee)

		poolBalanceToken0 := pool.BalanceToken0()
		poolBalanceToken1 := pool.BalanceToken1()

		diffToken0 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken0), sumOfToken0Balance)
		diffToken1 := i256.Zero().Sub(i256.FromUint256(poolBalanceToken1), sumOfToken1Balance)
		uassert.Equal(t, true, diffToken0.Lt(i256.NewInt(10)))
		uassert.Equal(t, true, diffToken1.Lt(i256.NewInt(10)))
	})

	t.Run("distribute ugnot token ", func(t *testing.T) {
		tokenAmountForDistribute := int64(1000000000000)
		fullTokenAmount := tokenAmountForDistribute * 1000000

		// 0. Set realm to admin
		testing.SetRealm(adminRealm)

		// 1. transfer ugnot
		testing.SetOriginCaller(adminAddr)
		newCoins := std.Coins{{"ugnot", fullTokenAmount}}
		distributeCoins := std.Coins{{"ugnot", tokenAmountForDistribute}}
		testing.IssueCoins(adminAddr, newCoins)
		testing.SetOriginSend(newCoins)
		banker := std.NewBanker(std.BankerTypeRealmSend)
		banker.SendCoins(adminAddr, aliceAddr, distributeCoins)
		banker.SendCoins(adminAddr, bobAddr, distributeCoins)
	})

	t.Run("IncreaseLiquidity #1 ", func(t *testing.T) {
		amount0Desired := "50000000"
		amount1Desired := "50000000"
		amount0Min := "0"
		amount1Min := "0"
		maxTimeout := time.Now().Add(time.Hour).Unix()
		referrerAddr := ""
		positionId := uint64(1)

		// Add Liquidity
		testing.SetRealm(aliceRealm)
		testing.SetOriginCaller(aliceAddr)
		addAmount, err := strconv.ParseInt(amount0Desired, 10, 64)
		if err != nil {
			t.Errorf("failed to parse amount0Requested: %v", err)
		}
		newCoinsForAdd := std.Coins{{"ugnot", addAmount}}
		testing.SetOriginSend(newCoinsForAdd)
		banker := std.NewBanker(std.BankerTypeRealmSend)
		banker.SendCoins(aliceAddr, positionAddr, newCoinsForAdd)
		testing.SetRealm(aliceRealm)
		cross(wugnot.Approve)(poolAddr, consts.UINT64_MAX)
		gns.Approve(poolAddr, consts.UINT64_MAX)
		cross(wugnot.Approve)(positionAddr, consts.UINT64_MAX)

		testing.SetRealm(aliceRealm)

		position, _ := GetPosition(positionId)
		pool := cross(pl.GetPoolFromPoolPath)(position.poolKey)
		currentSqrtPriceX96 := pool.Slot0SqrtPriceX96()
		lowerTickSqrtPriceX96 := common.TickMathGetSqrtRatioAtTick(position.tickLower)
		upperTickSqrtPriceX96 := common.TickMathGetSqrtRatioAtTick(position.tickUpper)
		beforeCalculatedToken0BalanceStr, beforeCalculatedToken1BalanceStr := common.GetAmountsForLiquidity(
			currentSqrtPriceX96,
			lowerTickSqrtPriceX96,
			upperTickSqrtPriceX96,
			position.liquidity,
		)

		positionId, liquidity, amount0Str, amount1Str, poolPath := IncreaseLiquidity(positionId, amount0Desired, amount1Desired, amount0Min, amount1Min, maxTimeout)

		position, _ = GetPosition(positionId)
		uassert.Equal(t, "17449591", amount0Str)
		uassert.Equal(t, "50000000", amount1Str)
		uassert.Equal(t, "110704589", liquidity)

		beforeToken0, _ := strconv.ParseUint(beforeCalculatedToken0BalanceStr, 10, 64)
		beforeToken1, _ := strconv.ParseUint(beforeCalculatedToken1BalanceStr, 10, 64)
		amount0, _ := strconv.ParseUint(amount0Str, 10, 64)
		amount1, _ := strconv.ParseUint(amount1Str, 10, 64)

		uassert.Equal(t, strconv.FormatUint(beforeToken0+amount0, 10), position.token0Balance.ToString())
		uassert.Equal(t, strconv.FormatUint(beforeToken1+amount1, 10), position.token1Balance.ToString())
	})
}
