package gnft

import (
	"std"
	"strings"
	"testing"

	"gno.land/p/demo/grc/grc721"
	"gno.land/p/nt/testutils"
	"gno.land/p/nt/uassert"

	_ "gno.land/r/gnoswap/rbac" // initialize rbac package
)

const (
	errInvalidTokenId = "invalid token id"
)

var (
	positionPath  = "gno.land/r/gnoswap/v1/position"
	positionRealm = std.NewCodeRealm(positionPath)

	stakerPath  = "gno.land/r/gnoswap/v1/staker"
	stakerRealm = std.NewCodeRealm(stakerPath)

	addr01      = testutils.TestAddress("addr01")
	addr01Realm = std.NewUserRealm(addr01)

	addr02      = testutils.TestAddress("addr02")
	addr02Realm = std.NewUserRealm(addr02)
)

func TestMetadata(t *testing.T) {
	tests := []struct {
		name     string
		fn       func() string
		expected string
	}{
		{"Name()", Name, "GNOSWAP NFT"},
		{"Symbol()", Symbol, "GNFT"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			uassert.Equal(t, tt.expected, tt.fn())
		})
	}
}

func TestBalanceOf(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(100))

	tests := []struct {
		name     string
		addr     std.Address
		expected int64
	}{
		{"BalanceOf(addr01)", addr01, 1},
		{"BalanceOf(addr02)", addr02, 0},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			balance, _ := BalanceOf(tt.addr)
			uassert.Equal(t, tt.expected, balance)
		})
	}
}

func TestTotalSupply(t *testing.T) {
	resetObject(t)
	tests := []struct {
		name     string
		setup    func(cur realm)
		expected int64
	}{
		{
			name:     "initial total supply",
			expected: 0,
		},
		{
			name: "total supply after minting",
			setup: func(cur realm) {
				testing.SetRealm(positionRealm)
				Mint(cur, addr01, tid(1))
				Mint(cur, addr01, tid(2))
			},
			expected: 2,
		},
		{
			name: "total supply after burning",
			setup: func(cur realm) {
				testing.SetRealm(positionRealm)
				Burn(cur, tid(2))
			},
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				testing.SetRealm(positionRealm)
				tt.setup(cross)
			}
			uassert.Equal(t, tt.expected, TotalSupply())
		})
	}
}

func TestOwnerOf(t *testing.T) {
	tests := []struct {
		name        string
		tokenId     uint64
		shouldPanic bool
		panicMsg    string
		expected    std.Address
	}{
		// {"OwnerOf(1)", 1, false, "", addr01},
		{"OwnerOf(500)", 500, false, errInvalidTokenId, addr01},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.shouldPanic {
				uassert.PanicsWithMessage(t, tt.panicMsg, func() {
					OwnerOf(tid(tt.tokenId))
				})
			} else {
				ownerAddr, err := OwnerOf(tid(tt.tokenId))
				if err != nil {
					uassert.Equal(t, tt.panicMsg, err.Error())
				} else {
					uassert.Equal(t, tt.expected, ownerAddr)
				}
			}
		})
	}
}

func TestIsApprovedForAll(t *testing.T) {
	tests := []struct {
		name             string
		isApprovedForAll bool
		expected         bool
	}{
		{
			name:             "IsApprovedForAll(addr01, addr02)",
			isApprovedForAll: false,
			expected:         false,
		},
		{
			name:             "IsApprovedForAll(addr01, addr02) after setting approval",
			isApprovedForAll: true,
			expected:         true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testing.SetRealm(addr01Realm)
			if tt.isApprovedForAll {
				SetApprovalForAll(cross, addr02, tt.isApprovedForAll)
			}
			uassert.Equal(t, tt.expected, IsApprovedForAll(addr01, addr02))
		})
	}
}

func TestSetTokenURI(t *testing.T) {
	tests := []struct {
		name             string
		callerRealm      std.Realm
		tokenId          uint64
		expectedHasAbort bool
		expectedErrMsg   string
	}{
		{
			name:             "set token uri expected error",
			callerRealm:      addr01Realm,
			tokenId:          1,
			expectedHasAbort: true,
			expectedErrMsg:   "[GNOSWAP-GNFT-002] cannot set URI || token id (1) has already set URI",
		},
		{
			name:             "set token uri is failed by not owner",
			callerRealm:      addr02Realm,
			tokenId:          1,
			expectedHasAbort: true,
			expectedErrMsg:   "[GNOSWAP-GNFT-002] cannot set URI || token id (1) has already set URI",
		},
		{
			name:             "set token uri is failed by empty token uri",
			callerRealm:      addr01Realm,
			tokenId:          1,
			expectedHasAbort: true,
			expectedErrMsg:   "[GNOSWAP-GNFT-002] cannot set URI || token id (1) has already set URI",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resetObject(t)

			// token id 1 is pre-minted
			testing.SetRealm(positionRealm)
			Mint(cross, addr01, tid(1))

			testing.SetRealm(tt.callerRealm)
			if tt.expectedHasAbort {
				uassert.AbortsWithMessage(t, tt.expectedErrMsg, func() {
					SetTokenURI(cross, tid(tt.tokenId), "not change")
				})
			} else {
				SetTokenURI(cross, tid(tt.tokenId), "not change")
			}
		})
	}
}

func TestGetApproved(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name         string
		setup        func(cur realm)
		tokenId      uint64
		expectedAddr std.Address
		shouldError  bool
		errorMsg     string
	}{
		{
			name:        "GetApproved for token without approval",
			tokenId:     1,
			shouldError: true,
			errorMsg:    "token id not approved for anyone",
		},
		{
			name: "GetApproved for token with approval",
			setup: func(cur realm) {
				testing.SetRealm(addr01Realm)
				Approve(cross, addr02, tid(1))
			},
			tokenId:      1,
			expectedAddr: addr02,
		},
		{
			name:        "GetApproved for non-existent token",
			tokenId:     999,
			shouldError: true,
			errorMsg:    "token id not approved for anyone",
		},
		{
			name: "GetApproved for token with different approval",
			setup: func(cur realm) {
				testing.SetRealm(addr01Realm)
				Approve(cross, addr02, tid(1))
				Approve(cross, testutils.TestAddress("addr03"), tid(1)) // change approval
			},
			tokenId:      1,
			expectedAddr: testutils.TestAddress("addr03"),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				tt.setup(cross)
			}

			addr, err := GetApproved(tid(tt.tokenId))

			if tt.shouldError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if err.Error() != tt.errorMsg {
					t.Errorf("Expected error message '%s', got '%s'", tt.errorMsg, err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Unexpected error: %v", err)
				}
				uassert.Equal(t, tt.expectedAddr, addr)
			}
		})
	}
}

func TestTransferFrom(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name              string
		setup             func(cur realm)
		callerRealm       std.Realm
		fromAddr          std.Address
		toAddr            std.Address
		tokenIdToTransfer uint64
		shouldPanic       bool
		panicMsg          string
		expected          std.Address
	}{
		{
			name:              "transfer non-existent token id",
			callerRealm:       stakerRealm,
			fromAddr:          addr01,
			toAddr:            addr02,
			tokenIdToTransfer: 99,
			shouldPanic:       true,
			panicMsg:          "invalid token id",
		},
		{
			name:              "transfer token owned by other user without approval",
			callerRealm:       stakerRealm,
			fromAddr:          addr01,
			toAddr:            addr02,
			tokenIdToTransfer: 1,
			shouldPanic:       true,
			panicMsg:          "caller is not token owner or approved || caller g1cceshmzzlmrh7rr3z30j2t5mrvsq9yccysw9nu is not owner g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st or approved for token 1",
		},
		{
			name: "transfer token owned by other user with approval",
			setup: func(cur realm) {
				testing.SetRealm(addr01Realm)
				Approve(cross, stakerRealm.Address(), tid(1))
			},
			callerRealm:       stakerRealm,
			fromAddr:          addr01,
			toAddr:            addr02,
			tokenIdToTransfer: 1,
		},
		{
			name: "transfer token owned by caller",
			setup: func(cur realm) {
				testing.SetRealm(addr02Realm)
				Approve(cross, stakerRealm.Address(), tid(1))
			},
			callerRealm:       stakerRealm,
			fromAddr:          addr02,
			toAddr:            addr01,
			tokenIdToTransfer: 1,
		},
		{
			name:              "transfer from is invalid address",
			callerRealm:       stakerRealm,
			fromAddr:          std.Address(""),
			toAddr:            addr02,
			tokenIdToTransfer: 1,
			shouldPanic:       true,
			panicMsg:          "[GNOSWAP-GNFT-004] invalid addresss || from address ()",
		},
		{
			name:              "transfer to is invalid address",
			callerRealm:       stakerRealm,
			fromAddr:          addr01,
			toAddr:            std.Address("this_is_invalid_address"),
			tokenIdToTransfer: 1,
			shouldPanic:       true,
			panicMsg:          "[GNOSWAP-GNFT-004] invalid addresss || to address (this_is_invalid_address)",
		},
		{
			name:              "not-staker contract transfer",
			callerRealm:       addr01Realm,
			fromAddr:          addr01,
			toAddr:            addr02,
			tokenIdToTransfer: 1,
			shouldPanic:       true,
			panicMsg:          "unauthorized: caller g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st is not staker",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				tt.setup(cross)
			}

			testing.SetRealm(tt.callerRealm)
			if tt.shouldPanic {
				uassert.AbortsWithMessage(t, tt.panicMsg, func() {
					TransferFrom(cross, tt.fromAddr, tt.toAddr, tid(tt.tokenIdToTransfer))
				})
			} else {
				testing.SetRealm(tt.callerRealm)
				TransferFrom(cross, tt.fromAddr, tt.toAddr, tid(tt.tokenIdToTransfer))
			}
		})
	}
}

func TestMint(t *testing.T) {
	tests := []struct {
		name            string
		callerRealm     std.Realm
		tokenIdToMint   uint64
		addressToMint   std.Address
		shouldPanic     bool
		panicMsg        string
		expected        string
		verifyTokenList func()
	}{
		{
			name:          "mint first nft to addr01",
			callerRealm:   positionRealm,
			tokenIdToMint: 1,
			addressToMint: addr01,
			expected:      "1",
			verifyTokenList: func() {
				balance, _ := BalanceOf(addr01)
				uassert.Equal(t, int64(1), balance)
			},
		},
		{
			name:          "mint second nft to addr02",
			callerRealm:   positionRealm,
			tokenIdToMint: 2,
			addressToMint: addr02,
			expected:      "2",
			verifyTokenList: func() {
				balance, _ := BalanceOf(addr02)
				uassert.Equal(t, int64(1), balance)
			},
		},
		{
			name:          "mint failed by existing token id",
			callerRealm:   positionRealm,
			tokenIdToMint: 0,
			addressToMint: addr01,
			shouldPanic:   true,
			panicMsg:      "token id already exists",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resetObject(t)

			// token id 0 is pre-minted
			testing.SetRealm(positionRealm)
			Mint(cross, testutils.TestAddress("human"), tid(0))

			if tt.shouldPanic {
				uassert.AbortsWithMessage(t, tt.panicMsg, func() {
					Mint(cross, tt.addressToMint, tid(tt.tokenIdToMint))
				})

				balance, _ := BalanceOf(tt.addressToMint)
				uassert.Equal(t, int64(0), balance)
			} else {
				testing.SetRealm(tt.callerRealm)
				mintedTokenId := Mint(cross, tt.addressToMint, tid(tt.tokenIdToMint))
				uassert.Equal(t, tt.expected, string(mintedTokenId))
				tt.verifyTokenList()
			}
		})
	}
}

func TestBurn(t *testing.T) {
	tests := []struct {
		name            string
		callerRealm     std.Realm
		tokenIdToBurn   uint64
		expectedBalance int64
		shouldPanic     bool
		panicMsg        string
	}{
		{
			name:            "burn success",
			tokenIdToBurn:   1,
			shouldPanic:     false,
			expectedBalance: 0,
		},
		{
			name:            "burn without permission",
			callerRealm:     std.NewUserRealm(addr01),
			tokenIdToBurn:   1,
			expectedBalance: 1,
			shouldPanic:     true,
			panicMsg:        "ownable: caller is not owner",
		},
		{
			name:            "burn non-existent token id",
			callerRealm:     positionRealm,
			tokenIdToBurn:   99,
			expectedBalance: 1,
			shouldPanic:     true,
			panicMsg:        errInvalidTokenId,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			resetObject(t)

			// token id 1 is pre-minted
			testing.SetRealm(positionRealm)
			Mint(cross, testutils.TestAddress("human"), tid(1))

			testing.SetRealm(tt.callerRealm)

			if tt.shouldPanic {
				uassert.AbortsWithMessage(t, tt.panicMsg, func() {
					Burn(cross, tid(tt.tokenIdToBurn))
				})
			} else {
				Burn(cross, tid(tt.tokenIdToBurn))
			}

			balance, _ := BalanceOf(testutils.TestAddress("human"))
			uassert.Equal(t, tt.expectedBalance, balance)
		})
	}
}

func TestTokenURI(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name        string
		tokenId     uint64
		shouldError bool
		errorMsg    string
	}{
		{
			name:        "valid token URI",
			tokenId:     1,
			shouldError: false,
		},
		{
			name:        "non-existent token",
			tokenId:     999,
			shouldError: true,
			errorMsg:    errInvalidTokenId,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			uri, err := TokenURI(tid(tt.tokenId))

			if tt.shouldError {
				uassert.Error(t, err)
				if err != nil {
					uassert.Equal(t, tt.errorMsg, err.Error())
				}
			} else {
				uassert.NoError(t, err)
				uassert.NotEmpty(t, uri)
				uassert.True(t, strings.HasPrefix(uri, "data:image/svg+xml;base64,"))
			}
		})
	}
}

func TestMustOwnerOf(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name        string
		tokenId     uint64
		shouldPanic bool
		panicMsg    string
		expected    std.Address
	}{
		{
			name:        "valid token",
			tokenId:     1,
			shouldPanic: false,
			expected:    addr01,
		},
		{
			name:        "non-existent token",
			tokenId:     999,
			shouldPanic: true,
			panicMsg:    errInvalidTokenId,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.shouldPanic {
				uassert.PanicsWithMessage(t, tt.panicMsg, func() {
					MustOwnerOf(tid(tt.tokenId))
				})
			} else {
				owner := MustOwnerOf(tid(tt.tokenId))
				uassert.Equal(t, tt.expected, owner)
			}
		})
	}
}

func TestSafeTransferFrom(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name        string
		setup       func(cur realm)
		callerRealm std.Realm
		from        std.Address
		to          std.Address
		tokenId     uint64
		shouldPanic bool
		panicMsg    string
	}{
		{
			name: "owner transfers own token",
			setup: func(cur realm) {
				testing.SetRealm(addr01Realm)
				Approve(cross, stakerRealm.Address(), tid(1))
			},
			callerRealm: stakerRealm,
			from:        addr01,
			to:          addr02,
			tokenId:     1,
			shouldPanic: false,
		},
		{
			name: "non-owner transfers without approval",
			setup: func(cur realm) {
				testing.SetRealm(addr02Realm)
				Approve(cross, stakerRealm.Address(), tid(1))
			},
			callerRealm: stakerRealm,
			from:        addr01,
			to:          addr02,
			tokenId:     1,
			shouldPanic: true,
			panicMsg:    "transfer from incorrect owner || from g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st is not the owner g1v9jxgu3sxf047h6lta047h6lta047h6l8tv5at of token 1",
		},
		{
			name:        "transfer non-existent token",
			callerRealm: stakerRealm,
			from:        addr01,
			to:          addr02,
			tokenId:     999,
			shouldPanic: true,
			panicMsg:    "invalid token id",
		},
		{
			name:        "transfer to zero address",
			callerRealm: stakerRealm,
			from:        addr01,
			to:          std.Address(""),
			tokenId:     1,
			shouldPanic: true,
			panicMsg:    "[GNOSWAP-GNFT-004] invalid addresss || to address ()",
		},
		{
			name:        "not-staker contract transfer",
			callerRealm: addr01Realm,
			from:        addr01,
			to:          addr02,
			tokenId:     1,
			shouldPanic: true,
			panicMsg:    "unauthorized: caller g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st is not staker",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if tt.setup != nil {
				tt.setup(cross)
			}

			testing.SetRealm(tt.callerRealm)

			if tt.shouldPanic {
				uassert.AbortsWithMessage(t, tt.panicMsg, func() {
					SafeTransferFrom(cross, tt.from, tt.to, tid(tt.tokenId))
				})
			} else {
				err := SafeTransferFrom(cross, tt.from, tt.to, tid(tt.tokenId))
				uassert.NoError(t, err)

				// Verify ownership transferred
				newOwner, _ := OwnerOf(tid(tt.tokenId))
				uassert.Equal(t, tt.to, newOwner)
			}
		})
	}
}

func TestExists(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))
	Mint(cross, addr01, tid(2))
	Burn(cross, tid(2))

	tests := []struct {
		name     string
		tokenId  uint64
		expected bool
	}{
		{
			name:     "existing token",
			tokenId:  1,
			expected: true,
		},
		{
			name:     "burned token",
			tokenId:  2,
			expected: false,
		},
		{
			name:     "never minted token",
			tokenId:  999,
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			exists := Exists(tid(tt.tokenId))
			uassert.Equal(t, tt.expected, exists)
		})
	}
}

func TestRender(t *testing.T) {
	tests := []struct {
		name     string
		path     string
		expected string
	}{
		{
			name:     "empty path",
			path:     "",
			expected: nft.RenderHome(),
		},
		{
			name:     "invalid path",
			path:     "invalid",
			expected: "404\n",
		},
		{
			name:     "another invalid path",
			path:     "/token/1",
			expected: "404\n",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := Render(tt.path)
			uassert.Equal(t, tt.expected, result)
		})
	}
}

func TestApprove(t *testing.T) {
	resetObject(t)
	testing.SetRealm(positionRealm)
	Mint(cross, addr01, tid(1))

	tests := []struct {
		name        string
		callerRealm std.Realm
		approved    std.Address
		tokenId     uint64
		shouldPanic bool
		panicMsg    string
	}{
		{
			name:        "owner approves address",
			callerRealm: addr01Realm,
			approved:    addr02,
			tokenId:     1,
			shouldPanic: false,
		},
		{
			name:        "non-owner tries to approve",
			callerRealm: addr02Realm,
			approved:    testutils.TestAddress("addr03"),
			tokenId:     1,
			shouldPanic: true,
			panicMsg:    "[GNOSWAP-GNFT-006] caller is not token owner or approved || caller g1v9jxgu3sxf047h6lta047h6lta047h6l8tv5at cannot approve for token 1 owned by g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st",
		},
		{
			name:        "approve for non-existent token",
			callerRealm: addr01Realm,
			approved:    addr02,
			tokenId:     999,
			shouldPanic: true,
			panicMsg:    "[GNOSWAP-GNFT-007] token does not exist || token 999",
		},
		{
			name:        "approve self",
			callerRealm: addr01Realm,
			approved:    addr01,
			tokenId:     1,
			shouldPanic: true,
			panicMsg:    "[GNOSWAP-GNFT-008] cannot transfer to self || cannot approve to current owner g1v9jxgu3sx9047h6lta047h6lta047h6l0js7st for token 1",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			testing.SetRealm(tt.callerRealm)

			if tt.shouldPanic {
				uassert.AbortsWithMessage(t, tt.panicMsg, func() {
					Approve(cross, tt.approved, tid(tt.tokenId))
				})
			} else {
				err := Approve(cross, tt.approved, tid(tt.tokenId))
				uassert.NoError(t, err)

				// Verify approval
				approved, _ := GetApproved(tid(tt.tokenId))
				uassert.Equal(t, tt.approved, approved)
			}
		})
	}
}

func resetObject(t *testing.T) {
	t.Helper()

	nft = grc721.NewBasicNFT("GNOSWAP NFT", "GNFT")
}
