package pool

import (
	"chain/runtime"

	"gno.land/p/nt/ufmt"
)

func (pv1 *PoolV1) assertIsNotAllowedEOA(previousRealm runtime.Realm) {
	if previousRealm.PkgPath() == "" {
		panic(newErrorWithDetail(
			errNotAccessEOA,
			ufmt.Sprintf("previousRealm(%s) is EOA", previousRealm.Address()),
		))
	}
}

// assertIsNotEqualsTokens asserts that the token0Path and token1Path are not equal.
func (pv1 *PoolV1) pv1.assertIsNotEqualsTokens(token0Path, token1Path string) {
	if token0Path == token1Path {
		panic(newErrorWithDetail(
			errDuplicateTokenInPool,
			ufmt.Sprintf("expected token0Path(%s) != token1Path(%s)", token0Path, token1Path),
		))
	}
}

// assertIsSupportedFeeTier asserts that the fee is a supported fee tier.
func (pv1 *PoolV1) assertIsSupportedFeeTier(fee uint32) {
	if !pv1.isValidFeeTier(fee) {
		panic(newErrorWithDetail(
			errUnsupportedFeeTier,
			ufmt.Sprintf("expected fee(%d) to be one of %d, %d, %d, %d", fee, FeeTier100, FeeTier500, FeeTier3000, FeeTier10000),
		))
	}
}

// assertIsNotExistsPoolPath asserts that the pool path does not exist.
func (pv1 *PoolV1) assertIsNotExistsPoolPath(token0Path, token1Path string, fee uint32) {
	poolPath := GetPoolPath(token0Path, token1Path, fee)

	if pools.Has(poolPath) {
		panic(newErrorWithDetail(
			errPoolAlreadyExists,
			ufmt.Sprintf("expected poolPath(%s:%s:%d) not to exist", token0Path, token1Path, fee),
		))
	}
}

// assertIsValidTicks validates the tick range for a liquidity position.
func (pv1 *PoolV1) assertIsValidTicks(tickLower, tickUpper int32) {
	if err := pv1.validateTicks(tickLower, tickUpper); err != nil {
		panic(err)
	}
}

// assertAmountSpecifiedIsNotZero asserts that the amountSpecified is not zero.
func (pv1 *PoolV1) assertAmountSpecifiedIsNotZero(amountSpecified string) {
	if amountSpecified == "0" {
		panic(newErrorWithDetail(
			errInvalidSwapAmount,
			ufmt.Sprintf("amountSpecified == 0"),
		))
	}
}

func (pv1 *PoolV1) assertPayerIsPreviousRealmOrOriginCaller(payer address) {
	if payer != runtime.PreviousRealm().Address() && payer != runtime.OriginCaller() {
		panic(newErrorWithDetail(
			errInvalidPayer,
			ufmt.Sprintf("expected payer(%s) to be the previous realm or the caller", payer),
		))
	}
}

func (pv1 *PoolV1) assertIsValidTokenOrder(token0Path, token1Path string) {
	if token0Path >= token1Path {
		panic(newErrorWithDetail(
			errInvalidInput,
			ufmt.Sprintf("expected token0Path(%s) < token1Path(%s)", token0Path, token1Path),
		))
	}
}
