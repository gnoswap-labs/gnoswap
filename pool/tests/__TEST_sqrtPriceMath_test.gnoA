package pool

import (
	"std"
	"testing"

	"gno.land/p/demo/json"

	"gno.land/r/onbloc/bar"
	"gno.land/r/onbloc/baz"
	"gno.land/r/onbloc/foo"

	"gno.land/r/gnoswap/v2/consts"

	"gno.land/r/gnoswap/v2/gns"

	"gno.land/p/demo/testutils"

	i256 "gno.land/p/gnoswap/int256"
	u256 "gno.land/p/gnoswap/uint256"

	"gno.land/r/gnoswap/v2/common"
)

var (
	got            *u256.Uint
	sqrtPX96       *u256.Uint
	liquidity      *u256.Uint
	liquidity_i256 *i256.Int
	amountIn       *u256.Uint
	amountOut      *u256.Uint
	zeroForOne     bool
	roundUp        bool
	expected       *u256.Uint
	Q128           *u256.Uint
	MaxUint256     *u256.Uint
	MaxUint256Sub1 *u256.Uint
	rst            bool
	sqrtRatioAX96  *u256.Uint
	sqrtRatioBX96  *u256.Uint
)

func TestGetNextSqrtPriceFromInput_1(t *testing.T) { //@Louis -
	// fails if price is zero
	sqrtPX96 = u256.Zero()
	liquidity = u256.Zero()
	amountIn = u256.MustFromDecimal("1000000000000000000") // 1e18
	zeroForOne = false
	amountIn.Div(amountIn, u256.NewUint(10))

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromInput_2(t *testing.T) { //@Louis -
	// fails if liquidity is zero
	sqrtPX96 = u256.One()
	liquidity = u256.Zero()
	amountIn = u256.MustFromDecimal("1000000000000000000") // 1e18
	zeroForOne = true
	amountIn.Div(amountIn, u256.NewUint(10))

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromInput_3(t *testing.T) { //@Louis -
	// fails if input amount overflows the price

	sqrtPX96 = u256.NewUint(2)
	sqrtPX96.Exp(sqrtPX96, u256.NewUint(160))
	sqrtPX96.Sub(sqrtPX96, u256.One())
	liquidity = u256.NewUint(1024)
	amountIn = u256.NewUint(1024)
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromInput_4(t *testing.T) {
	// any input amount cannot underflow the price
	sqrtPX96 = u256.One()
	liquidity = u256.One()
	amountIn = u256.NewUint(2)
	amountIn.Exp(amountIn, u256.NewUint(225))
	zeroForOne = true

	expected = u256.One()

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("any input amount cannot underflow the price")
	}
}

func TestGetNextSqrtPriceFromInput_5(t *testing.T) {
	// returns input price if amount in is zero and zeroForOne = true
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	liquidity.Div(liquidity, u256.NewUint(10))
	amountIn = u256.Zero()
	zeroForOne = true

	expected = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("returns input price if amount in is zero and zeroForOne = true")
	}
}

func TestGetNextSqrtPriceFromInput_6(t *testing.T) {
	// returns input price if amount in is zero and zeroForOne = false
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	liquidity.Div(liquidity, u256.NewUint(10))
	amountIn = u256.Zero()
	zeroForOne = false

	expected = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("returns input price if amount in is zero and zeroForOne = false")
	}
}

func TestGetNextSqrtPriceFromInput_7(t *testing.T) {
	var maxAmountNoOverflow *u256.Uint
	var a *u256.Uint

	// returns the minimum price for max inputs
	sqrtPX96 = u256.NewUint(2)
	sqrtPX96.Exp(sqrtPX96, u256.NewUint(160))
	sqrtPX96.Sub(sqrtPX96, u256.NewUint(1))

	liquidity = u256.MustFromDecimal(consts.MAX_UINT128)
	a = u256.MustFromDecimal(consts.MAX_UINT128)
	maxAmountNoOverflow = u256.MustFromDecimal(consts.MAX_UINT256)
	a.Lsh(a, 96)
	a.Div(a, sqrtPX96)
	maxAmountNoOverflow.Sub(maxAmountNoOverflow, a)

	zeroForOne = true

	expected = u256.One()

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, maxAmountNoOverflow, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("returns the minimum price for max inputs")
	}
}

func TestGetNextSqrtPriceFromInput_8(t *testing.T) {
	// input amount of 0.1 token1
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	amountIn = u256.MustFromDecimal("1000000000000000000")
	amountIn.Div(amountIn, u256.NewUint(10))
	zeroForOne = false

	expected = u256.MustFromDecimal("87150978765690771352898345369")

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("input amount of 0.1 token1")
	}
}

func TestGetNextSqrtPriceFromInput_9(t *testing.T) {
	// input amount of 0.1 token1
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	amountIn = u256.MustFromDecimal("1000000000000000000")
	amountIn.Div(amountIn, u256.NewUint(10))
	zeroForOne = true

	expected = u256.MustFromDecimal("72025602285694852357767227579")

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("input amount of 0.1 token1")
	}
}

func TestGetNextSqrtPriceFromInput_10(t *testing.T) {
	// amountIn > type(uint96).max and zeroForOne = true
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("10000000000000000000")         // 10e18
	amountIn = u256.MustFromDecimal("2")
	amountIn.Exp(amountIn, u256.NewUint(100))
	zeroForOne = true

	expected = u256.MustFromDecimal("624999999995069620")

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("amountIn > type(uint96).max and zeroForOne = true")
	}
}

func TestGetNextSqrtPriceFromInput_11(t *testing.T) {
	// can return 1 with enough amountIn and zeroForOne = true
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1")
	amountIn = u256.MustFromDecimal(consts.MAX_UINT256)
	amountIn.Div(amountIn, u256.NewUint(2))
	zeroForOne = true

	expected = u256.MustFromDecimal("1")

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("can return 1 with enough amountIn and zeroForOne = true")
	}
}

/*
 TODO: snapshotGasCost
*/

func TestGetNextSqrtPriceFromOutput_1(t *testing.T) {
	// fails if price is zero
	sqrtPX96 = u256.Zero()
	liquidity = u256.Zero()
	amountOut = u256.MustFromDecimal("1000000000000000000") // 1e18
	amountOut.Div(amountOut, u256.NewUint(10))
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_2(t *testing.T) { //@Louis -
	// fails if liquidity is zero
	sqrtPX96 = u256.One()
	liquidity = u256.Zero()
	amountOut = u256.MustFromDecimal("1000000000000000000") // 1e18
	amountOut.Div(amountOut, u256.NewUint(10))
	zeroForOne = true

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_3(t *testing.T) {
	// fails if output amount is exactly the virtual reserves of token0
	sqrtPX96 = u256.MustFromDecimal("20282409603651670423947251286016")
	liquidity = u256.NewUint(1024)
	amountOut = u256.MustFromDecimal("4")
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_4(t *testing.T) {
	// fails if output amount is greater than virtual reserves of token0
	sqrtPX96 = u256.MustFromDecimal("20282409603651670423947251286016")
	liquidity = u256.NewUint(1024)
	amountOut = u256.MustFromDecimal("5")
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_5(t *testing.T) {
	// fails if output amount is exactly the virtual reserves of token1
	sqrtPX96 = u256.MustFromDecimal("20282409603651670423947251286016")
	liquidity = u256.NewUint(1024)
	amountOut = u256.MustFromDecimal("262144")
	zeroForOne = true

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_6(t *testing.T) {
	// succeeds if output amount is just less than the virtual reserves of token1
	sqrtPX96 = u256.MustFromDecimal("20282409603651670423947251286016")
	liquidity = u256.NewUint(1024)
	amountOut = u256.MustFromDecimal("262143")
	zeroForOne = true

	expected = u256.MustFromDecimal("77371252455336267181195264")

	got = SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 77371252455336267181195264")
	}
}

func TestGetNextSqrtPriceFromOutput_7(t *testing.T) {
	// puzzling echidna test
	sqrtPX96 = u256.MustFromDecimal("20282409603651670423947251286016")
	liquidity = u256.NewUint(1024)
	amountOut = u256.MustFromDecimal("4")
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_8(t *testing.T) {
	// returns input price if amount in is zero and zeroForOne = true
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	liquidity.Div(liquidity, u256.NewUint(10))
	amountOut = u256.Zero()
	zeroForOne = true

	expected = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336

	got = SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 79228162514264337593543950336")
	}
}

func TestGetNextSqrtPriceFromOutput_9(t *testing.T) {
	// returns input price if amount in is zero and zeroForOne = false

	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	liquidity.Div(liquidity, u256.NewUint(10))
	amountOut = u256.Zero()
	zeroForOne = false
	expected = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336

	got = SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 79228162514264337593543950336")
	}
}

func TestGetNextSqrtPriceFromOutput_10(t *testing.T) {
	// output amount of 0.1 token1
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	amountOut = u256.MustFromDecimal("1000000000000000000")
	amountOut.Div(amountOut, u256.NewUint(10))
	zeroForOne = false
	expected = u256.MustFromDecimal("88031291682515930659493278152")

	got = SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 88031291682515930659493278152")
	}
}

func TestGetNextSqrtPriceFromOutput_11(t *testing.T) {
	// output amount of 0.1 token1
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	amountOut = u256.MustFromDecimal("1000000000000000000")
	amountOut.Div(amountOut, u256.NewUint(10))
	zeroForOne = true
	expected = u256.MustFromDecimal("71305346262837903834189555302")

	got = SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 71305346262837903834189555302")
	}
}

func TestGetNextSqrtPriceFromOutput_12(t *testing.T) {
	// reverts if amountOut is impossible in zero for one direction
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.One()
	amountOut = u256.MustFromDecimal(consts.MAX_UINT256)
	zeroForOne = true

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestGetNextSqrtPriceFromOutput_13(t *testing.T) {
	// reverts if amountOut is impossible in one for zero direction
	sqrtPX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.One()
	amountOut = u256.MustFromDecimal(consts.MAX_UINT256)
	zeroForOne = false

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetNextSqrtPriceFromOutput(sqrtPX96, liquidity, amountOut, zeroForOne)
		},
	)
}

func TestSqrtPriceMathGetAmount0DeltaStr_1(t *testing.T) {
	var got_string string
	// returns 0 if liquidity is 0

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336")  // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("112045541949572279837463876454") // encodePriceSqrt(2, 1) = 112045541949572279837463876454
	liquidity_i256 = i256.Zero()

	got_string = SqrtPriceMathGetAmount0DeltaStr(sqrtRatioAX96, sqrtRatioBX96, liquidity_i256)

	if got_string != "0" {
		t.Errorf("return value should be eq to 0")
	}
}

func TestSqrtPriceMathGetAmount0DeltaHelper_1(t *testing.T) {
	// returns 0 if liquidity is 0

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336")  // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("112045541949572279837463876454") // encodePriceSqrt(2, 1) = 112045541949572279837463876454
	liquidity = u256.Zero()
	roundUp = true

	expected = u256.Zero()

	got = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	rst = got.Eq(expected)
	if !rst {
		t.Errorf("return value should be eq to 0")
	}
}

func TestSqrtPriceMathGetAmount0DeltaStr_2(t *testing.T) {
	var got_string string
	// returns 0 if prices are equal

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity_i256 = i256.Zero()

	got_string = SqrtPriceMathGetAmount0DeltaStr(sqrtRatioAX96, sqrtRatioBX96, liquidity_i256)

	if got_string != "0" {
		t.Errorf("return value should be eq to 0")
	}
}

func TestSqrtPriceMathGetAmount0DeltaStr_3(t *testing.T) { //@Louis -
	var got_string string
	// return value should be eq to 90909090909090910

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("87150978765690771352898345369") // encodePriceSqrt(121, 100) = 87150978765690771352898345369
	liquidity_i256 = i256.MustFromDecimal("1000000000000000000")

	got_string = SqrtPriceMathGetAmount0DeltaStr(sqrtRatioAX96, sqrtRatioBX96, liquidity_i256)

	if got_string != "90909090909090910" {
		t.Errorf("return value should be eq to 90909090909090910")
	}
}

func TestSqrtPriceMathGetAmount0DeltaStr_4(t *testing.T) { //@Louis -
	var got_string string
	// return value should be eq to 90909090909090910

	sqrtRatioAX96 = u256.MustFromDecimal("2787593149816327892691964784081045188247552")  // encodePriceSqrt(BigNumber.from(2).pow(90), 1) = 2787593149816327892691964784081045188247552
	sqrtRatioBX96 = u256.MustFromDecimal("22300745198530623141535718272648361505980416") // encodePriceSqrt(BigNumber.from(2).pow(96), 1) = 22300745198530623141535718272648361505980416
	liquidity_i256 = i256.MustFromDecimal("1000000000000000000")

	got_string = SqrtPriceMathGetAmount0DeltaStr(sqrtRatioAX96, sqrtRatioBX96, liquidity_i256)

	// println(got_string)//0

	if got_string == "0" {
		t.Errorf("The result should not return 0")
	}
}

func TestSqrtPriceMathGetAmount0DeltaHelper_2(t *testing.T) {
	// returns 0 if prices are equal

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.Zero()
	roundUp = true

	expected = u256.Zero()

	got = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	rst = got.Eq(expected)
	if !rst {
		t.Errorf("return value should be eq to 0")
	}
}

func TestSqrtPriceMathGetAmount0DeltaHelper_3(t *testing.T) { //@Louis -
	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("87150978765690771352898345369") // encodePriceSqrt(121, 100) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("1000000000000000000")
	roundUp = true

	expected = u256.MustFromDecimal("90909090909090910")

	got = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should be eq to 90909090909090910")
	}
}

func TestSqrtPriceMathGetAmount0DeltaHelper_4(t *testing.T) {
	// the sub between the result of roundup and rounddown should be eq to 1
	var got2 *u256.Uint
	sqrtRatioAX96 = u256.MustFromDecimal("112045541949572279837463876454") // encodePriceSqrt(2, 1) = 112045541949572279837463876454
	sqrtRatioBX96 = u256.MustFromDecimal("87150978765690771352898345369")  // encodePriceSqrt(121, 100) = 87150978765690771352898345369
	liquidity = u256.MustFromDecimal("1000000000000000000")
	roundUp = true

	got = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	roundUp = false

	got2 = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	got.Sub(got, got2)

	rst = got.Eq(u256.One())

	if !rst {
		t.Errorf("the sub between the result of roundup and rounddown should be eq to 1")
	}
}

func TestSqrtPriceMathGetAmount0DeltaHelper_5(t *testing.T) {
	// works for prices that overflow

	var got2 *u256.Uint
	sqrtRatioAX96 = u256.MustFromDecimal("2787593149816327892691964784081045188247552")  // encodePriceSqrt(BigNumber.from(2).pow(90), 1) = 2787593149816327892691964784081045188247552
	sqrtRatioBX96 = u256.MustFromDecimal("22300745198530623141535718272648361505980416") // encodePriceSqrt(BigNumber.from(2).pow(96), 1) = 22300745198530623141535718272648361505980416
	liquidity = u256.MustFromDecimal("1000000000000000000")
	roundUp = true

	got = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	roundUp = false

	got2 = SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	// println(got.ToString())
	// println(got2.ToString())
	got.Sub(got, got2)

	rst = got.Eq(u256.One())

	if !rst {
		t.Errorf("the sub between the result of roundup and rounddown should be eq to 1")
	}
}

func TestSqrtPriceMathGetAmount1DeltaHelper_1(t *testing.T) {
	// returns 0 if liquidity is 0

	var got2 *u256.Uint
	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336")  // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("112045541949572279837463876454") // encodePriceSqrt(2, 1) = 112045541949572279837463876454
	liquidity = u256.MustFromDecimal("0")
	roundUp = true

	shouldPanic(
		t,
		func() {
			SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)
		},
	)
}

func TestSqrtPriceMathGetAmount1DeltaHelper_2(t *testing.T) {
	// returns 0 if prices are equal

	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	liquidity = u256.MustFromDecimal("0")
	roundUp = true

	expected = u256.Zero()

	got = SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("returns 0 if prices are equal")
	}
}

func TestSqrtPriceMathGetAmount1DeltaHelper_3(t *testing.T) {
	var got2 *u256.Uint
	// returns 0.1 amount1 for price of 1 to 1.21
	sqrtRatioAX96 = u256.MustFromDecimal("79228162514264337593543950336") // encodePriceSqrt(1, 1) = 79228162514264337593543950336
	sqrtRatioBX96 = u256.MustFromDecimal("87150978765690771352898345369") // encodePriceSqrt(121, 100) = 87150978765690771352898345369
	liquidity = u256.MustFromDecimal("1000000000000000000")
	roundUp = true

	expected = u256.MustFromDecimal("100000000000000000") // 0.1e18

	got = SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("the result should be eq to expected")
	}
	roundUp = false

	got2 = SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity, roundUp)
	got.Sub(got, got2)

	rst = got.Eq(u256.One())
	if !rst {
		t.Errorf("the sub between the result of roundup and rounddown should be eq to 1")
	}
}

func TestSwapComputation(t *testing.T) {
	// sqrtP * sqrtQ overflows

	sqrtPX96 = u256.MustFromDecimal("1025574284609383690408304870162715216695788925244")
	liquidity = u256.MustFromDecimal("50015962439936049619261659728067971248")
	amountIn = u256.NewUint(406)
	zeroForOne = true

	expected = u256.MustFromDecimal("1025574284609383582644711336373707553698163132913")

	got = SqrtPriceMathGetNextSqrtPriceFromInput(sqrtPX96, liquidity, amountIn, zeroForOne)

	rst = got.Eq(expected)

	if !rst {
		t.Errorf("The result should eq to expected")
	}

	got = SqrtPriceMathGetAmount0DeltaHelper(expected, sqrtPX96, liquidity, true)

	rst = got.Eq(u256.NewUint(406))

	if !rst {
		t.Errorf("The result should eq to 406")
	}
}


//===================For Test =================

func SqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(
	sqrtPX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint128
	amount *u256.Uint, // uint256
	add bool,
) *u256.Uint { // uint160
	if amount.IsZero() {
		return sqrtPX96
	}

	numerator1 := new(u256.Uint).Lsh(liquidity, 96)
	product := new(u256.Uint).Mul(amount, sqrtPX96)

	if add {
		if new(u256.Uint).Div(product, amount).Eq(sqrtPX96) {
			denominator := new(u256.Uint).Add(numerator1, product)

			if denominator.Gte(numerator1) {
				return u256.MulDivRoundingUp(numerator1, sqrtPX96, denominator)
			}
		}

		div := new(u256.Uint).Div(numerator1, sqrtPX96)
		add := new(u256.Uint).Add(div, amount)
		return u256.DivRoundingUp(numerator1, add)
	} else {
		cond1 := new(u256.Uint).Div(product, amount).Eq(sqrtPX96)
		cond2 := numerator1.Gt(product)

		if !(cond1 && cond2) {
			panic("common_sqrt price math #1")
		}

		denominator := new(u256.Uint).Sub(numerator1, product)
		return u256.MulDivRoundingUp(numerator1, sqrtPX96, denominator)
	}
}

func SqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(
	sqrtPX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint1288
	amount *u256.Uint, // uint256
	add bool,
) *u256.Uint { // uint160
	quotient := u256.Zero()

	if add {
		if amount.Lte(u256.MustFromDecimal(consts.MAX_UINT160)) {
			value1 := new(u256.Uint).Lsh(amount, 96)
			quotient = new(u256.Uint).Div(value1, liquidity)
		} else {
			quotient = u256.MulDiv(amount, u256.MustFromDecimal(consts.Q96), liquidity)
		}

		return new(u256.Uint).Add(sqrtPX96, quotient)
	} else {
		if amount.Lte(u256.MustFromDecimal(consts.MAX_UINT160)) {
			value1 := new(u256.Uint).Lsh(amount, 96)
			quotient = u256.DivRoundingUp(value1, liquidity)
		} else {
			quotient = u256.MulDivRoundingUp(amount, u256.MustFromDecimal(consts.Q96), liquidity)
		}

		if !(sqrtPX96.Gt(quotient)) {
			panic("common_sqrt price math #2")
		}

		return new(u256.Uint).Sub(sqrtPX96, quotient)
	}
}

func SqrtPriceMathGetNextSqrtPriceFromInput(
	sqrtPX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint128
	amountIn *u256.Uint, // uint256
	zeroForOne bool, // bool
) *u256.Uint { // uint160
	if sqrtPX96.IsZero() {
		panic("sqrtPX96 should not be zero")
	}

	if liquidity.IsZero() {
		panic("liquidity should not be zero")
	}

	if zeroForOne {
		return SqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
	}
	return SqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true)
}

func SqrtPriceMathGetNextSqrtPriceFromOutput(
	sqrtPX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint128
	amountOut *u256.Uint, // uint256
	zeroForOne bool, // bool
) *u256.Uint { // uint160
	if liquidity.IsZero() {
		panic("liquidity should not be zero")
	}

	if zeroForOne {
		return SqrtPriceMathGetNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
	}

	return SqrtPriceMathGetNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false)
}

func SqrtPriceMathGetAmount0DeltaHelper(
	sqrtRatioAX96 *u256.Uint, // uint160
	sqrtRatioBX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint160
	roundUp bool,
) *u256.Uint { // uint256
	if sqrtRatioAX96.Gt(sqrtRatioBX96) {
		sqrtRatioAX96, sqrtRatioBX96 = sqrtRatioBX96, sqrtRatioAX96
	}

	numerator1 := new(u256.Uint).Lsh(liquidity, 96)
	numerator2 := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)

	if !(sqrtRatioAX96.Gt(u256.Zero())) {
		panic("common_sqrt price math #3")
	}

	if roundUp {
		value1 := u256.MulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96)
		return u256.DivRoundingUp(value1, sqrtRatioAX96)
	} else {
		value1 := u256.MulDiv(numerator1, numerator2, sqrtRatioBX96)
		return new(u256.Uint).Div(value1, sqrtRatioAX96)
	}
}

func SqrtPriceMathGetAmount1DeltaHelper(
	sqrtRatioAX96 *u256.Uint, // uint160
	sqrtRatioBX96 *u256.Uint, // uint160
	liquidity *u256.Uint, // uint160
	roundUp bool,
) *u256.Uint { // uint256
	if liquidity.IsZero() {
		panic("liquidity should not be zero")
	}

	if sqrtRatioAX96.Gt(sqrtRatioBX96) {
		sqrtRatioAX96, sqrtRatioBX96 = sqrtRatioBX96, sqrtRatioAX96
	}

	if roundUp {
		diff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)
		return u256.MulDivRoundingUp(liquidity, diff, u256.MustFromDecimal(consts.Q96))
	} else {
		diff := new(u256.Uint).Sub(sqrtRatioBX96, sqrtRatioAX96)
		return u256.MulDiv(liquidity, diff, u256.MustFromDecimal(consts.Q96))
	}
}

func SqrtPriceMathGetAmount0DeltaStr(
	sqrtRatioAX96 *u256.Uint, // uint160
	sqrtRatioBX96 *u256.Uint, // uint160
	liquidity *i256.Int, // int128
) string { // int256
	if liquidity.IsNeg() {
		u := SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), false)
		i := i256.FromUint256(u)
		return i256.Zero().Neg(i).ToString()
	}

	u := SqrtPriceMathGetAmount0DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), true)
	return i256.FromUint256(u).ToString()
}

func SqrtPriceMathGetAmount1DeltaStr(
	sqrtRatioAX96 *u256.Uint, // uint160
	sqrtRatioBX96 *u256.Uint, // uint160
	liquidity *i256.Int, // int128
) string { // int256
	if liquidity.IsNeg() {
		u := SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), false)
		i := i256.FromUint256(u)
		return i256.Zero().Neg(i).ToString()
	}

	u := SqrtPriceMathGetAmount1DeltaHelper(sqrtRatioAX96, sqrtRatioBX96, liquidity.Abs(), true)
	return i256.FromUint256(u).ToString()
}
