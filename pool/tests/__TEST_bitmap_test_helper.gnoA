package pool

import (
	"gno.land/p/demo/ufmt"
	"gno.land/r/gnoswap/v2/consts"

	plp "gno.land/p/gnoswap/pool"

	u256 "gno.land/p/gnoswap/uint256"
)

var (
	tickBitmaps map[int16]*u256.Uint = make(map[int16]*u256.Uint)
)
// tickBitmapPosition calculates the word and bit position for a given tick
func TickBitmapPosition_Helper(tick int32) (int16, uint8) {
	wordPos := int16(tick >> 8) // tick / 256
	bitPos := uint8(tick % 256)

	return wordPos, bitPos
}

// tickBitmapFlipTick flips tthe bit corresponding to the given tick
// in the pool's tick bitmap.
//
// Panics:
//   - If tick % tickSpacing != 0
func TickBitmapFlipTick_Helper(
	tick int32,
	tickSpacing int32,
) {
	if tick%tickSpacing != 0 {
		panic(ufmt.Sprintf("[POOL] tick_bitmap.gno__tickBitmapFlipTick() || tick(%d) MOD tickSpacing(%d) != 0(%d)", tick, tickSpacing, tick%tickSpacing))
	}

	wordPos, bitPos := TickBitmapPosition_Helper(tick / tickSpacing)

	// 1 << bitPos
	mask := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))

	tickBitmaps[wordPos] = tickBitmaps[wordPos].NilToZero()
	tickBitmaps[wordPos] = new(u256.Uint).Xor(tickBitmaps[wordPos], mask)
}

// tickBitmapNextInitializedTickWithInOneWord finds the next initialized tick within
// one word of the bitmap.
func TickBitmapNextInitializedTickWithInOneWord_Helper(
	tick int32,
	tickSpacing int32,
	lte bool,
) (int32, bool) {
	compress := tick / tickSpacing
	if tick < 0 && tick % tickSpacing != 0 {
		compress--
	}

	if lte {
		wordPos, bitPos := TickBitmapPosition_Helper(compress)

		// mask := (1 << bitPos) - 1 + (1 << bitPos)
		shift1LeftByBitPos := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))
		println("-----------------")
		println("shift1LeftByBitPos", shift1LeftByBitPos.ToString())
		mask := shift1LeftByBitPos.Clone()
		mask = new(u256.Uint).Sub(mask, u256.NewUint(1))
		println("mask1", mask.ToString())
		mask = new(u256.Uint).Add(mask, shift1LeftByBitPos.Clone())
		println("mask2", mask.ToString())
		tickBitmaps[wordPos] = tickBitmaps[wordPos].NilToZero()
		println("tickBitmaps[wordPos]", tickBitmaps[wordPos].ToString())
		masked := new(u256.Uint).And(tickBitmaps[wordPos], mask)
		println("BitMathMostSignificantBit(masked)", plp.BitMathMostSignificantBit(masked))
		println("bitPos",bitPos)
		println("compress",compress)
		
		initialized := !(masked.IsZero())

		if initialized {
			next := compress - int32(bitPos-plp.BitMathMostSignificantBit(masked)) * tickSpacing
			return next, initialized
		}

		next := (compress - int32(bitPos)) * tickSpacing
		return next, initialized
		
	}

	wordPos, bitPos := TickBitmapPosition_Helper(compress + 1)

	shift1LeftByBitPos := new(u256.Uint).Lsh(u256.NewUint(1), uint(bitPos))
	_mask := shift1LeftByBitPos.Clone()
	_mask = new(u256.Uint).Sub(_mask, u256.NewUint(1))
	mask := BitwiseNotForUint256BitmapIndexing_Helper(_mask)

	tickBitmaps[wordPos] = tickBitmaps[wordPos].NilToZero()
	masked := new(u256.Uint).And(tickBitmaps[wordPos], mask)

	initialized := !(masked.IsZero())
	if initialized {
		
		next := (compress + 1 + int32(plp.BitMathLeastSignificantBit(masked)-bitPos)) * tickSpacing
		return next, initialized
	} else {
		
		next := (compress + 1 + int32(255-bitPos)) * tickSpacing

		return next, initialized
	}
}

// bitwiseNotForUint256BitmapIndexing performs a bitwise NsOT operation on the uint256 value.
// This function is designed for use in bitmap indexing
func BitwiseNotForUint256BitmapIndexing_Helper(x *u256.Uint) *u256.Uint {
	// REF: https://stackoverflow.com/a/77071037

	// Create a mask with all bits set to 1
	mask := u256.MustFromDecimal(consts.MAX_UINT256)
	mask = new(u256.Uint).Sub(mask, u256.NewUint(1))

	// XOR with mask to perform bitwise NOT
	// result := x ^ mask

	result := new(u256.Uint).Xor(x, mask)
	return result
}

func InitializeTickBitmaps_Helper() {
	tickBitmaps = make(map[int16]*u256.Uint)
}

func GetTickBitmaps_Helper() map[int16]*u256.Uint {
	return tickBitmaps
}

func IsInitialized_Helper(tick int32 , ts int32 ) (int32, bool) {
	nextTick, init := TickBitmapNextInitializedTickWithInOneWord_Helper(tick, ts, true)
	if (nextTick == tick) {
		return nextTick, init
	} else {
		return nextTick, false
	}
}
