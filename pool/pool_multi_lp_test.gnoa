package gnoswap

import (
	"math"
	"std"
	"testing"

	"gno.land/p/demo/testutils"
	"gno.land/r/demo/users"

	"gno.land/r/bar"
	"gno.land/r/foo"
)

var (
	lp01 = testutils.TestAddress("lp01") // Liquidity Provider 01
	lp02 = testutils.TestAddress("lp02") // Liquidity Provider 02
	lp03 = testutils.TestAddress("lp03") // Liquidity Provider 03

	sp01 = testutils.TestAddress("sp01") // Swap Executor 01

	gso = testutils.TestAddress("gso") // Gnoswap Owner - Will receive protocol fees
)

func init() {
	std.TestSetOrigCaller(lp01)
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()

	std.TestSetOrigCaller(lp02)
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()

	std.TestSetOrigCaller(lp03)
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()

	std.TestSetOrigCaller(sp01)
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	foo.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
	bar.Faucet()
}

var (
	// Common
	test_tickLower       bigint = 9000
	test_tickUpper       bigint = 11000
	test_liquidityExpect bigint = 1000

	test_tickLower2 bigint = 50000
	test_tickUpper2 bigint = 100000
)

func TestPoolMultiLP(t *testing.T) {
	pool := testInit(t)
	testMint(t, pool)
	testBurn(t, pool)
	testCollect(t, pool)
	testSwap(t, pool)
	testSetFeeProtocol(t, pool)
	testCollectProtocol(t, pool)

	// getter api
	testGetPoolInfo(t, pool)
	testGetTokenInfo(t, pool)
	testGetUserInfo(t, pool)
}

func testInit(t *testing.T) *Pool {
	var (
		// 500		= 0.05% // USv3 default
		// 3000		= 0.3% // USv3 default
		// 10000	= 1% // USv3 default
		test_fee bigint = 3000

		test_tickSpacing bigint = 10
		test_sqrtPrice   bigint = 130621891405341611593710811006 // tick = 10_000
	)
	// XXX old
	// Init(
	// 	test_fee,
	// 	test_tickSpacing,
	// 	test_sqrtPrice,
	// )

	pool := NewPool(
		"gno.land/r/foo",
		"gno.land/r/bar",
		test_fee,
		test_tickSpacing,
		test_sqrtPrice,
	)

	std.TestSetOrigCaller(lp01)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp01), 50000000)
	bar.Approve(users.AddressOrName(lp01), 50000000)

	std.TestSetOrigCaller(lp02)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp02), 50000000)
	bar.Approve(users.AddressOrName(lp02), 50000000)

	std.TestSetOrigCaller(lp03)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp03), 50000000)
	bar.Approve(users.AddressOrName(lp03), 50000000)

	std.TestSetOrigCaller(sp01)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(sp01), 50000000)
	bar.Approve(users.AddressOrName(sp01), 50000000)

	return pool
}

func testMint(t *testing.T, pool *Pool) {
	std.TestSetOrigCaller(lp01)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)

	test_liquidity := pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect)

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	m1, m2 := pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	m11, m12 := pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)

	shouldNEQ(t, m1, bigint(0))
	shouldNEQ(t, m2, bigint(0))
	shouldEQ(t, m1, m11)
	shouldEQ(t, m2, m12)

	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	// tickLower > currentTick == don't add to current liquidity
	// 50_000
	// 100_000
	pool.Mint(lp01, test_tickLower2, test_tickUpper2, test_liquidityExpect)

	// tickUpper < current tick == don't add to current liquidity
	// -100_000
	// -50_000
	pool.Mint(lp01, -test_tickUpper2, -test_tickLower2, test_liquidityExpect)

	// // tickUpper < tickLower == don't add to current liquidity
	// // -11_000
	// // -9_000
	pool.Mint(lp01, -test_tickUpper, -test_tickLower, test_liquidityExpect)

	// test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*20)
}

func testBurn(t *testing.T, pool *Pool) {
	b1, b2 := pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect)
	b11, b12 := pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect)
	shouldEQ(t, b1, b11)
	shouldEQ(t, b2, b12)

	test_liquidity := pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*18)

	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*8)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	pool.Burn(test_tickLower, test_tickUpper, 1)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, bigint(9999))

	pool.Burn(test_tickLower, test_tickUpper, bigint(999))
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*9)

	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*9)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, bigint(0))

	// can't burn when liq is 0
	// (pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect))
	shouldPanic(t, func() { pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect) })
}

func testCollect(t *testing.T, pool *Pool) {
	// withdraw all token
	pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c1, c2 := pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c3, c4 := pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	shouldEQ(t, c1, c3)
	shouldEQ(t, c2, c4)

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c5, c6 := pool.Collect(lp01, test_tickLower, test_tickUpper, 100, 100)
	shouldEQ(t, c5, bigint(100))
	shouldEQ(t, c6, bigint(100))

	c7, c8 := pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldEQ(t, c7, c3-bigint(100))
	shouldEQ(t, c8, c4-bigint(100))

	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	// pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect * 15)
	// no burn => no collect
	c9, c10 := pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldEQ(t, c9, bigint(0))
	shouldEQ(t, c10, bigint(0))

	// burn => some collect
	pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c11, c12 := pool.Collect(lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldNEQ(t, c11, bigint(0))
	shouldNEQ(t, c12, bigint(0))
}

func testSwap(t *testing.T, pool *Pool) {
	std.TestSetOrigCaller(lp02)
	pool.Mint(lp02, test_tickLower, test_tickUpper, test_liquidityExpect*1000)

	std.TestSetOrigCaller(lp03)
	pool.Mint(lp03, test_tickLower, test_tickUpper, test_liquidityExpect*1000)

	test_price := bigint(MIN_SQRT_RATIO + 1)

	{
		println("Swap #1")
		println("ㄴ direction: token0 -> token1")
		println("ㄴ amount: 10000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, sp01)
		userOldToken1Bal := BalanceOf(pool.token1, sp01)

		lp03OldToken0Bal := BalanceOf(pool.token0, lp03)
		lp03OldToken1Bal := BalanceOf(pool.token1, lp03)

		std.TestSetOrigCaller(sp01)
		amount0, amount1 := pool.Swap(sp01, true, bigint(10000), test_price) // give enough amount to take fees away

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, sp01)
		userNewToken1Bal := BalanceOf(pool.token1, sp01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("ㄴ token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("ㄴ token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader sp01")
		println("ㄴ token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("ㄴ token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")

		std.TestSetOrigCaller(lp03)
		pool.Burn(test_tickLower, test_tickUpper, test_liquidityExpect*1000)
		pool.Collect(lp03, test_tickLower, test_tickUpper, 50000000, 50000000)

		lp03NewToken0Bal := BalanceOf(pool.token0, lp03)
		lp03NewToken1Bal := BalanceOf(pool.token1, lp03)

		println("LP lp03")
		println("ㄴ token0:", lp03OldToken0Bal, "->", lp03NewToken0Bal, "( diff:", lp03NewToken0Bal-lp03OldToken0Bal, ")")
		println("ㄴ token1:", lp03OldToken1Bal, "->", lp03NewToken1Bal, "( diff:", lp03NewToken1Bal-lp03OldToken1Bal, ")")
		println()
	}

	{
		println("Swap #2")
		println("ㄴ direction: token0 -> token1")
		println("ㄴ amount: 5000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, sp01)
		userOldToken1Bal := BalanceOf(pool.token1, sp01)

		std.TestSetOrigCaller(sp01)
		amount0, amount1 := pool.Swap(sp01, true, 5000, test_price)

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, sp01)
		userNewToken1Bal := BalanceOf(pool.token1, sp01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("ㄴ token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("ㄴ token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader sp01")
		println("ㄴ token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("ㄴ token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #3")
		println("ㄴ direction: token0 -> token1")
		println("ㄴ amount: 1000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, sp01)
		userOldToken1Bal := BalanceOf(pool.token1, sp01)

		amount0, amount1 := pool.Swap(sp01, true, 1000, test_price) // give enough amount to take fees away

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, sp01)
		userNewToken1Bal := BalanceOf(pool.token1, sp01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("ㄴ token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("ㄴ token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader sp01")
		println("ㄴ token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("ㄴ token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #4")
		println("ㄴ direction: token1 -> token0")
		println("ㄴ amount: 16000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, sp01)
		userOldToken1Bal := BalanceOf(pool.token1, sp01)

		amount0, amount1 := pool.Swap(sp01, false, 16000, bigint(MAX_SQRT_RATIO-1)) // give enough amount to take fees away

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, sp01)
		userNewToken1Bal := BalanceOf(pool.token1, sp01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("ㄴ token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("ㄴ token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader sp01")
		println("ㄴ token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("ㄴ token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}
}

func testSetFeeProtocol(t *testing.T, pool *Pool) {
	test_slot0 := pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(0))

	pool.SetFeeProtocol(0, 0)
	test_slot0 = pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(0))

	pool.SetFeeProtocol(0, 4)
	test_slot0 = pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(64))

	pool.SetFeeProtocol(4, 0)
	test_slot0 = pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(4))

	pool.SetFeeProtocol(6, 8)
	test_slot0 = pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(134))

	// out of pre-defined range
	shouldPanic(t, func() { pool.SetFeeProtocol(2, 2) })
}

func testCollectProtocol(t *testing.T, pool *Pool) {
	pool.SetFeeProtocol(6, 8)
	test_slot0 := pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(134))

	std.TestSetOrigCaller(lp01)
	pool.Mint(lp01, test_tickLower, test_tickUpper, test_liquidityExpect*150)

	{
		println("Swap #5 - with protocol fees")
		println("ㄴ direction: token0 -> token1")
		println("ㄴ amount: 2000000")

		gsoOldToken0Bal := BalanceOf(pool.token0, gso)
		gsoOldToken1Bal := BalanceOf(pool.token1, gso)

		std.TestSetOrigCaller(sp01)
		pool.Swap(sp01, true, 100000, bigint(MIN_SQRT_RATIO+1)) // swap token0 -> token1 => fee only in token0
		pool.Swap(sp01, true, 100000, bigint(MIN_SQRT_RATIO+1)) // more protocol fees

		std.TestSetOrigCaller(gso)
		amount0, amount1 := pool.CollectProtocol(gso, 100000, 100000)

		gsoNewToken0Bal := BalanceOf(pool.token0, gso)
		gsoNewToken1Bal := BalanceOf(pool.token1, gso)

		println("Gnoswap Owner")
		println("ㄴ token0:", gsoOldToken0Bal, "->", gsoNewToken0Bal, "( diff:", gsoNewToken0Bal-gsoOldToken0Bal, ")")
		println("ㄴ token1:", gsoOldToken1Bal, "->", gsoNewToken1Bal, "( diff:", gsoNewToken1Bal-gsoOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #6 - with protocol fees")
		println("ㄴ direction: token1 -> token0")
		println("ㄴ amount: 200000")

		gsoOldToken0Bal := BalanceOf(pool.token0, gso)
		gsoOldToken1Bal := BalanceOf(pool.token1, gso)

		std.TestSetOrigCaller(sp01)
		pool.Swap(sp01, false, 100000, bigint(MAX_SQRT_RATIO-1)) // swap token0 -> token1 => fee only in token0
		pool.Swap(sp01, false, 100000, bigint(MAX_SQRT_RATIO-1)) // more protocol fees

		std.TestSetOrigCaller(gso)
		amount0, amount1 := pool.CollectProtocol(gso, 100000, 100000)

		gsoNewToken0Bal := BalanceOf(pool.token0, gso)
		gsoNewToken1Bal := BalanceOf(pool.token1, gso)

		println("Gnoswap Owner")
		println("ㄴ token0:", gsoOldToken0Bal, "->", gsoNewToken0Bal, "( diff:", gsoNewToken0Bal-gsoOldToken0Bal, ")")
		println("ㄴ token1:", gsoOldToken1Bal, "->", gsoNewToken1Bal, "( diff:", gsoNewToken1Bal-gsoOldToken1Bal, ")")
		println()
	}
}

/* GETTER_API TEST */
func testGetPoolInfo(t *testing.T, pool *Pool) {
	tapi := pool.ApiGetPoolInfo()
	// println(tapi)
}

func testGetTokenInfo(t *testing.T, pool *Pool) {
	tapi0 := ApiGetTokenInfo(pool.token0)
	// println(tapi0)

	tapi1 := ApiGetTokenInfo(pool.token1)
	// println(tapi1)
}

func testGetUserInfo(t *testing.T, pool *Pool) {
	uapi := pool.ApiGetUserInfo("g1d3crqv2lta047h6lta047h6lta047h6lnjw069")
	// println(uapi)
}

/* HELPER */

func shouldEQ(t *testing.T, got, expected interface{}) {
	if got != expected {
		t.Errorf("got %v, expected %v", got, expected)
	}
}

func shouldNEQ(t *testing.T, got, expected interface{}) {
	if got == expected {
		t.Errorf("got %v, expected %v", got, expected)
	}
}

func shouldPanic(t *testing.T, f func()) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("expected panic")
		}
	}()
	f()
}