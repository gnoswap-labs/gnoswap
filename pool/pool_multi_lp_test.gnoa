package gnoswap

import (
	"math"
	"std"
	"testing"

	"gno.land/p/demo/testutils"
	"gno.land/r/demo/users"

	bar "gno.land/r/bar"
	foo "gno.land/r/foo"
)

var (
	gsa = testutils.TestAddress("gsa") // Gnoswap Admin

	lp01 = testutils.TestAddress("lp01") // Liquidity Provider 01
	lp02 = testutils.TestAddress("lp02") // Liquidity Provider 02
	lp03 = testutils.TestAddress("lp03") // Liquidity Provider 03

	tr01 = testutils.TestAddress("tr01") // Trader 01

)

func init() {
	std.TestSetOrigCaller(lp01)
	foo.FaucetL()
	bar.FaucetL()

	std.TestSetOrigCaller(lp02)
	foo.FaucetL()
	bar.FaucetL()

	std.TestSetOrigCaller(lp03)
	foo.FaucetL()
	bar.FaucetL()

	std.TestSetOrigCaller(tr01)
	foo.FaucetL()
	bar.FaucetL()

	// debug - print addr
	// println(gsa, "// gsa")
	// println(lp01, "// lp01")
	// println(lp02, "// lp03")
	// println(lp02, "// lp03")
	// println(tr01, "// tr01")
	// println(GetOrigPkgAddr(), "// pool")
}

var (
	// Common
	pToken0        = "foo"
	pToken1        = "bar"
	pFee    bigint = 500

	test_tickLower       bigint = 9000
	test_tickUpper       bigint = 11000
	test_liquidityExpect bigint = 1000

	test_tickLower2 bigint = 50000
	test_tickUpper2 bigint = 100000
)

// 1. Init & Create Pool using Factory Contract by gsa
func TestFactoryCreatePool(t *testing.T) {
	std.TestSetOrigCaller(gsa)
	Init()
	CreatePool("foo", "bar", pFee, 130621891405341611593710811006)

	// fee
	// 500		= 0.05% // USv3 default
	// 3000		= 0.3% // USv3 default
	// 10000	= 1% // USv3 default

	// sqrtPrice
	// 130621891405341611593710811006 // tick = 10000
	shouldPanic(t, func() { CreatePool("foo", "bar", 500, 130621891405341611593710811006) })

	// Approve
	std.TestSetOrigCaller(lp01)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp01), 50000000)
	bar.Approve(users.AddressOrName(lp01), 50000000)

	std.TestSetOrigCaller(lp02)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp02), 50000000)
	bar.Approve(users.AddressOrName(lp02), 50000000)

	std.TestSetOrigCaller(lp03)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(lp03), 50000000)
	bar.Approve(users.AddressOrName(lp03), 50000000)

	std.TestSetOrigCaller(tr01)
	foo.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	bar.Approve(users.AddressOrName(GetOrigPkgAddr()), 50000000)
	foo.Approve(users.AddressOrName(tr01), 50000000)
	bar.Approve(users.AddressOrName(tr01), 50000000)
}

// 2. Mint by lp01
func TestMint(t *testing.T) {
	std.TestSetOrigCaller(lp01)
	Mint(
		pToken0,
		pToken1,
		pFee,
		lp01,
		test_tickLower,
		test_tickUpper,
		test_liquidityExpect,
	)

	pool := GetPool(pToken0, pToken1, pFee)
	test_liquidity := pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect)

	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)

	m81, m82 := Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	m101, m102 := Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)

	shouldNEQ(t, m81, bigint(0))
	shouldNEQ(t, m82, bigint(0))
	shouldEQ(t, m81, m101)
	shouldEQ(t, m82, m102)

	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	// tickLower > currentTick == don't add to current liquidity
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower2, test_tickUpper2, test_liquidityExpect)

	// tickUpper < current tick == don't add to current liquidity
	Mint(pToken0, pToken1, pFee, lp01, -test_tickUpper2, -test_tickLower2, test_liquidityExpect)

	// tickUpper < tickLower == don't add to current liquidity
	Mint(pToken0, pToken1, pFee, lp01, -test_tickUpper, -test_tickLower, test_liquidityExpect)

	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect)

	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*20)
}

// 3. Burn by lp01
func TestBurn(t *testing.T) {
	std.TestSetOrigCaller(lp01)

	b11, b12 := Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect)
	b21, b22 := Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect)
	shouldEQ(t, b11, b21)
	shouldEQ(t, b12, b22)

	pool := GetPool(pToken0, pToken1, pFee)
	test_liquidity := pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*18)

	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*8)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*10)

	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, 1)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, bigint(9999))

	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, 999)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, test_liquidityExpect*9)

	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*9)
	test_liquidity = pool.GetLiquidity()
	shouldEQ(t, test_liquidity, bigint(0))

	// can't burn when liq is 0
	// Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect)
	shouldPanic(t, func() { Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect) })
}

// 4. Collect
func TestCollect(t *testing.T) {
	// withdraw all token before test `Collect`
	Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	// pool should have zero liquidity
	pool := GetPool(pToken0, pToken1, pFee)
	test_liquidity := pool.GetLiquidity()
	shouldEQ(t, test_liquidity, bigint(0))

	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c11, c12 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c21, c22 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)

	shouldEQ(t, c11, c21)
	shouldEQ(t, c12, c22)

	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c31, c32 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 100, 100)
	shouldEQ(t, c31, bigint(100))
	shouldEQ(t, c32, bigint(100))

	c41, c42 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldEQ(t, c41, c21-bigint(100))
	shouldEQ(t, c42, c22-bigint(100))

	// Mint > No Burn => nothing to collect
	Mint(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	// Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c51, c52 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldEQ(t, c51, bigint(0))
	shouldEQ(t, c52, bigint(0))

	// Burn Now => something to collect
	Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*15)
	c61, c62 := Collect(pToken0, pToken1, pFee, lp01, test_tickLower, test_tickUpper, 50000000, 50000000)
	shouldNEQ(t, c61, bigint(0))
	shouldNEQ(t, c62, bigint(0))
}

// 5. Swap by tr01, Mint by lp02 ~ lp03
func TestSwap(t *testing.T) {
	pool := GetPool(pToken0, pToken1, pFee)

	std.TestSetOrigCaller(lp02)
	Mint(pToken0, pToken1, pFee, lp02, test_tickLower, test_tickUpper, test_liquidityExpect*10000)

	std.TestSetOrigCaller(lp03)
	Mint(pToken0, pToken1, pFee, lp03, test_tickLower, test_tickUpper, test_liquidityExpect*10000)

	// Swap several times
	test_price := bigint(MIN_SQRT_RATIO + 1) // maximum price

	{
		println("Swap #1")
		println("> direction: token0 -> token1")
		println("> amount: 10000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, tr01)
		userOldToken1Bal := BalanceOf(pool.token1, tr01)

		lp02OldToken0Bal := BalanceOf(pool.token0, lp02)
		lp02OldToken1Bal := BalanceOf(pool.token1, lp02)

		lp03OldToken0Bal := BalanceOf(pool.token0, lp03)
		lp03OldToken1Bal := BalanceOf(pool.token1, lp03)

		std.TestSetOrigCaller(tr01)
		amount0, amount1 := Swap(
			pToken0,
			pToken1,
			pFee,
			tr01,
			true,
			bigint(10000),
			test_price,
		)

		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, tr01)
		userNewToken1Bal := BalanceOf(pool.token1, tr01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("> token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("> token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader tr01")
		println("> token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("> token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()

		std.TestSetOrigCaller(lp02)
		Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*1000)
		Collect(pToken0, pToken1, pFee, lp02, test_tickLower, test_tickUpper, 50000000, 50000000)

		lp02NewToken0Bal := BalanceOf(pool.token0, lp02)
		lp02NewToken1Bal := BalanceOf(pool.token1, lp02)

		println("Liquidity Provider lp02")
		println("> token0:", lp02OldToken0Bal, "->", lp02NewToken0Bal, "( diff:", lp02NewToken0Bal-lp02OldToken0Bal, ")")
		println("> token1:", lp02OldToken1Bal, "->", lp02NewToken1Bal, "( diff:", lp02NewToken1Bal-lp02OldToken1Bal, ")")
		println()

		std.TestSetOrigCaller(lp03)
		Burn(pToken0, pToken1, pFee, test_tickLower, test_tickUpper, test_liquidityExpect*1000)
		Collect(pToken0, pToken1, pFee, lp03, test_tickLower, test_tickUpper, 50000000, 50000000)

		lp03NewToken0Bal := BalanceOf(pool.token0, lp03)
		lp03NewToken1Bal := BalanceOf(pool.token1, lp03)

		println("Liquidity Provider lp03")
		println("> token0:", lp03OldToken0Bal, "->", lp03NewToken0Bal, "( diff:", lp03NewToken0Bal-lp03OldToken0Bal, ")")
		println("> token1:", lp03OldToken1Bal, "->", lp03NewToken1Bal, "( diff:", lp03NewToken1Bal-lp03OldToken1Bal, ")")
		println()
	}

	// Mint again
	std.TestSetOrigCaller(lp02)
	Mint(pToken0, pToken1, pFee, lp02, test_tickLower, test_tickUpper, test_liquidityExpect*1000)

	std.TestSetOrigCaller(lp03)
	Mint(pToken0, pToken1, pFee, lp03, test_tickLower, test_tickUpper, test_liquidityExpect*1000)

	{
		println("Swap #2")
		println("> direction: token0 -> token1")
		println("> amount: 5000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, tr01)
		userOldToken1Bal := BalanceOf(pool.token1, tr01)

		std.TestSetOrigCaller(tr01)
		amount0, amount1 := Swap(pToken0, pToken1, pFee, tr01, true, bigint(5000), test_price)

		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, tr01)
		userNewToken1Bal := BalanceOf(pool.token1, tr01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("> token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("> token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader tr01")
		println("> token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("> token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #3")
		println("> direction: token0 -> token1")
		println("> amount: 1000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, tr01)
		userOldToken1Bal := BalanceOf(pool.token1, tr01)

		std.TestSetOrigCaller(tr01)
		amount0, amount1 := Swap(pToken0, pToken1, pFee, tr01, true, bigint(1000), test_price)

		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, tr01)
		userNewToken1Bal := BalanceOf(pool.token1, tr01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("> token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("> token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader tr01")
		println("> token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("> token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #4")
		println("> direction: token1 -> token0")
		println("> amount: 16000")

		poolOldToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolOldToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userOldToken0Bal := BalanceOf(pool.token0, tr01)
		userOldToken1Bal := BalanceOf(pool.token1, tr01)

		std.TestSetOrigCaller(tr01)
		amount0, amount1 := Swap(pToken0, pToken1, pFee, tr01, false, bigint(16000), (MAX_SQRT_RATIO - 1))

		shouldNEQ(t, amount0, bigint(0))
		shouldNEQ(t, amount1, bigint(0))

		poolNewToken0Bal := BalanceOf(pool.token0, GetOrigPkgAddr())
		poolNewToken1Bal := BalanceOf(pool.token1, GetOrigPkgAddr())

		userNewToken0Bal := BalanceOf(pool.token0, tr01)
		userNewToken1Bal := BalanceOf(pool.token1, tr01)

		shouldEQ(t, userOldToken0Bal-amount0, userNewToken0Bal)
		shouldEQ(t, userOldToken1Bal-amount1, userNewToken1Bal)
		shouldEQ(t, poolOldToken0Bal+amount0, poolNewToken0Bal)
		shouldEQ(t, poolOldToken1Bal+amount1, poolNewToken1Bal)

		println("Pool")
		println("> token0:", poolOldToken0Bal, "->", poolNewToken0Bal, "( diff:", poolNewToken0Bal-poolOldToken0Bal, ")")
		println("> token1:", poolOldToken1Bal, "->", poolNewToken1Bal, "( diff:", poolNewToken1Bal-poolOldToken1Bal, ")")

		println("Trader tr01")
		println("> token0:", userOldToken0Bal, "->", userNewToken0Bal, "( diff:", userNewToken0Bal-userOldToken0Bal, ")")
		println("> token1:", userOldToken1Bal, "->", userNewToken1Bal, "( diff:", userNewToken1Bal-userOldToken1Bal, ")")
		println()
	}
}

func TestSetFeeProtocol(t *testing.T) {
	// non admin call
	std.TestSetOrigCaller(lp01)
	shouldPanic(t, func() { SetFeeProtocol(2, 2) })

	// admin call
	std.TestSetOrigCaller(gsa)
	SetFeeProtocol(6, 8)

	for i := 0; i < pools.Size(); i++ {
		k, _ := pools.GetByIndex(i)
		pool := GetPoolFromPoolKey(k)

		shouldEQ(t, pool.GetSlot0().feeProtocol, bigint(134))
	}
}

func TestCollectProtocol(t *testing.T) {
	std.TestSetOrigCaller(gsa)

	SetFeeProtocol(6, 8)
	pool := GetPool(pToken0, pToken1, pFee)
	test_slot0 := pool.GetSlot0()
	shouldEQ(t, test_slot0.feeProtocol, bigint(134))

	// Make ProtocolFee via Swap by tr01 ( Mint by lp01 )
	std.TestSetOrigCaller(lp01)
	{
		println("Swap #5 - with protocol fee enabled")
		println("> direction: token0 -> token1")
		println("> amount: 2000000")

		gsaOldToken0Bal := BalanceOf(pool.token0, gsa)
		gsaOldToken1Bal := BalanceOf(pool.token1, gsa)

		std.TestSetOrigCaller(tr01)
		Swap(pToken0, pToken1, pFee, tr01, true, 100000, MIN_SQRT_RATIO+1) // swap token0 -> token1 => fee only in token0
		Swap(pToken0, pToken1, pFee, tr01, true, 100000, MIN_SQRT_RATIO+1) // more protocol fee

		// Gnoswap Admin
		std.TestSetOrigCaller(gsa)
		amount0, amount1 := CollectProtocol(pToken0, pToken1, pFee, gsa, 100000, 100000)

		gsaNewToken0Bal := BalanceOf(pool.token0, gsa)
		gsaNewToken1Bal := BalanceOf(pool.token1, gsa)

		println("Gnoswap Admin")
		println("> token0:", gsaOldToken0Bal, "->", gsaNewToken0Bal, "( diff:", gsaNewToken0Bal-gsaOldToken0Bal, ")")
		println("> token1:", gsaOldToken1Bal, "->", gsaNewToken1Bal, "( diff:", gsaNewToken1Bal-gsaOldToken1Bal, ")")
		println()
	}

	{
		println("Swap #6 - with protocol fee enabled")
		println("> direction: token1 -> token0")
		println("> amount: 2000000")

		gsaOldToken0Bal := BalanceOf(pool.token0, gsa)
		gsaOldToken1Bal := BalanceOf(pool.token1, gsa)

		std.TestSetOrigCaller(tr01)
		Swap(pToken0, pToken1, pFee, tr01, false, 100000, MAX_SQRT_RATIO-1) // swap token0 -> token1 => fee only in token0
		Swap(pToken0, pToken1, pFee, tr01, false, 100000, MAX_SQRT_RATIO-1) // more protocol fee

		// Gnoswap Admin
		std.TestSetOrigCaller(gsa)
		amount0, amount1 := CollectProtocol(pToken0, pToken1, pFee, gsa, 100000, 100000)

		gsaNewToken0Bal := BalanceOf(pool.token0, gsa)
		gsaNewToken1Bal := BalanceOf(pool.token1, gsa)

		println("Gnoswap Admin")
		println("> token0:", gsaOldToken0Bal, "->", gsaNewToken0Bal, "( diff:", gsaNewToken0Bal-gsaOldToken0Bal, ")")
		println("> token1:", gsaOldToken1Bal, "->", gsaNewToken1Bal, "( diff:", gsaNewToken1Bal-gsaOldToken1Bal, ")")
		println()
	}
}

/* GETTER_API TEST */
func TestApiGetPools(t *testing.T) {
	gpls := ApiGetPools()
	println(gpls)
}

func TestApiGetPool(t *testing.T) {
	pk := "bar_foo_500"
	gpl := ApiGetPool(pk)
	println(gpl)
}

/* HELPER */
func shouldEQ(t *testing.T, got, expected interface{}) {
	if got != expected {
		t.Errorf("got %v, expected %v", got, expected)
	}
}

func shouldNEQ(t *testing.T, got, expected interface{}) {
	if got == expected {
		t.Errorf("got %v, didn't expected %v", got, expected)
	}
}

func shouldPanic(t *testing.T, f func()) {
	defer func() {
		if r := recover(); r == nil {
			t.Errorf("expected panic")
		}
	}()
	f()
}
